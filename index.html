
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="format-detection" content="telephone=no">
    <title>Relational-Spatial Dual N-Back</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f9fafb;
            padding: 1.5rem;
            min-height: 100vh;
        }

        .container {
            max-width: 72rem;
            margin: 0 auto;
        }

        .card {
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1.5rem;
        }

        .header-right {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            align-items: flex-end;
        }

        .title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .title h1 {
            font-size: 1.875rem;
            font-weight: bold;
            color: #374151;
        }

        .score-display {
            font-size: 0.875rem;
            font-weight: 600;
            text-align: right;
        }

        .settings-display {
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            padding: 0.75rem;
            font-size: 0.75rem;
            color: #6b7280;
            text-align: right;
            line-height: 1.4;
        }

        .settings-display .setting-item {
            display: block;
            margin-bottom: 0.25rem;
        }

        .settings-display .setting-item:last-child {
            margin-bottom: 0;
        }

        /* Mode Selection Screen */
        .mode-selection-screen, .setup-screen, .results-screen, .game-screen {
            text-align: center;
        }

        .mode-options {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
            max-width: 600px;
            margin: 0 auto;
        }

        .mode-card {
            border: 2px solid #e5e7eb;
            border-radius: 1rem;
            padding: 2rem;
            cursor: pointer;
            transition: all 0.3s;
            background: white;
        }

        .mode-card:hover {
            border-color: #3b82f6;
            background: #f8fafc;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .mode-card.selected {
            border-color: #3b82f6;
            background: #eff6ff;
        }

        .mode-card h3 {
            font-size: 1.5rem;
            font-weight: bold;
            color: #1f2937;
            margin-bottom: 0.75rem;
        }

        .mode-card p {
            color: #6b7280;
            font-size: 0.875rem;
            line-height: 1.5;
        }

        /* Setup Screen */
        .setup-controls {
            max-width: 28rem;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .control-group label {
            font-size: 0.875rem;
            font-weight: 500;
        }

        .control-group input[type="range"] {
            width: 100%;
        }

        .instructions {
            font-size: 0.875rem;
            color: #6b7280;
            max-width: 48rem;
            margin: 0 auto;
            line-height: 1.5;
        }

        /* Game Screen */
        .game-layout {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3rem;
            margin-bottom: 2rem;
            min-height: 600px;
            position: relative;
            width: 100%;
        }

        .side-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            flex: 0 0 180px;
            min-height: 400px;
            justify-content: center;
            position: relative;
        }

        .side-control .feedback {
            position: absolute;
            bottom: -60px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            min-width: 120px;
        }

        .side-control .building-history {
            position: absolute;
            bottom: -100px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            min-width: 150px;
            text-align: center;
        }

        .grid-container {
            flex: 0 0 auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .spatial-btn, .relational-btn, .advanced-btn, .single-task-btn {
            width: 140px;
            height: 140px;
            border: 3px solid transparent;
            border-radius: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
            font-weight: bold;
            background: white;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .spatial-btn {
            border-color: #16a34a;
            color: #16a34a;
        }

        .spatial-btn:hover, .spatial-btn.active {
            background: #16a34a;
            color: white;
            transform: scale(1.05);
        }

        .relational-btn {
            border-color: #2563eb;
            color: #2563eb;
        }

        .relational-btn:hover, .relational-btn.active {
            background: #2563eb;
            color: white;
            transform: scale(1.05);
        }

        .advanced-btn {
            border-color: #7c3aed;
            color: #7c3aed;
        }

        .advanced-btn:hover, .advanced-btn.active {
            background: #7c3aed;
            color: white;
            transform: scale(1.05);
        }

        .btn-title {
            font-size: 1.3rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .btn-key {
            font-size: 0.9rem;
            font-weight: normal;
            opacity: 0.8;
        }

        .spatial-btn.disabled, .relational-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .spatial-btn.disabled:hover, .relational-btn.disabled:hover {
            background: white;
            color: inherit;
            transform: none;
        }

        /* Grid Styles - FIXED */
        .spatial-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            width: fit-content;
            margin: 0 auto;
            border: 2px solid #6b7280;
            gap: 1px;
            background-color: #6b7280;
        }

        .grid-cell {
            width: 280px;
            height: 280px;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 1.5rem;
            transition: all 0.2s;
            background: #f3f4f6;
            overflow: visible;
            position: relative;
        }

        .grid-cell.active {
            background: #3b82f6;
            color: white;
        }

        /* Cognitive interference effects for Spatial N-Back */
        .grid-cell.fake-active {
            background: rgba(59, 130, 246, 0.4);
        }
        
        .grid-cell.distorted {
            transform: skew(5deg, 5deg);
        }

        .grid-cell.rotated {
            transform: rotate(180deg);
        }

        .grid-cell.shifted {
            transform: translate(5px, 5px);
        }

        .grid-cell.color-shift {
            background: linear-gradient(45deg, #f3f4f6, #fecaca);
        }

        .interference-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                45deg,
                rgba(255, 255, 255, 0.1),
                rgba(255, 255, 255, 0.1) 10px,
                rgba(0, 0, 0, 0.05) 10px,
                rgba(0, 0, 0, 0.05) 20px
            );
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .interference-flash {
            animation: flash 0.3s;
        }

        .interference-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        .interference-symbol {
            position: absolute;
            font-size: 20px;
            opacity: 0.6;
            pointer-events: none;
        }

        @keyframes flash {
            0%, 50% { opacity: 0.7; }
            25%, 75% { opacity: 0; }
            100% { opacity: 0; }
        }

        /* Mirror Grid (for interference) */
        .mirror-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.2;
            pointer-events: none;
            transform: rotate(180deg);
        }

        .premise-text {
            font-size: var(--premise-font-size, 1.2rem);
            line-height: 1.3;
            font-weight: 600;
            width: 100%;
            max-width: 100%;
            word-wrap: break-word;
            hyphens: auto;
            white-space: normal;
            overflow: visible;
        }

        .premise-text div {
            margin-bottom: var(--premise-spacing, 0.5rem);
            white-space: normal;
            overflow: visible;
            word-wrap: break-word;
            max-width: 100%;
        }

        .premise-text div:last-child {
            margin-bottom: 0;
        }

        /* Single Task Layouts - FIXED */
        .single-task-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3rem;
            margin-bottom: 2rem;
            min-height: 600px;
        }

        .single-task-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            flex: 0 0 180px;
        }

        .grid-container {
            flex: 0 0 auto;
        }

        .single-task-btn {
            width: 160px;
            height: 160px;
        }

        /* Relational N-Back Layout */
        .relational-layout {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0;
            margin-bottom: 2rem;
            min-height: 600px;
            position: relative;
            width: 100%;
            padding-left: 0;
        }

        .relational-controls {
            position: absolute;
            left: 50px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            min-height: 400px;
            justify-content: center;
        }

        .premise-display-area {
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 0 0 auto;
        }

        /* Advanced mode positioning - adjust to accommodate glossary */
        .advanced-layout {
            justify-content: center;
            padding-left: 0;
            margin-left: 0;
        }

        .advanced-layout .relational-controls {
            position: static;
            left: auto;
            flex: 0 0 180px;
        }

        .advanced-layout .premise-display-area {
            margin-left: 0;
        }

        /* Ultra mode specific positioning for glossary */
        .ultra-layout {
            justify-content: flex-start;
            padding-left: 0;
            margin-left: -150px;
        }

        /* Ensure feedback doesn't affect positioning */
        .relational-controls .feedback {
            position: absolute;
            bottom: -60px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            min-width: 120px;
        }

        .relational-controls .building-history {
            position: absolute;
            bottom: -100px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            min-width: 150px;
            text-align: center;
        }

        .premise-display-box {
            background: #3b82f6;
            color: white;
            border: 2px solid #2563eb;
            border-radius: 1rem;
            padding: 1.2rem;
            width: 683px;
            height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            position: relative;
        }

        .premise-display-box.advanced-box {
            background: #7c3aed;
            border-color: #6d28d9;
            width: 900px;
            height: 500px;
        }

        /* Ultra mode specific styling */
        .premise-display-box.ultra-box {
            background: #7c3aed;
            border-color: #6d28d9;
            width: 900px;
            height: 500px;
        }

        /* Glossary for Ultra mode */
        .ultra-glossary {
            background: rgba(124, 58, 237, 0.95);
            color: white;
            border: 2px solid #6d28d9;
            border-radius: 0.75rem;
            padding: 1.25rem;
            width: 320px;
            font-size: 0.75rem;
            line-height: 1.3;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            margin-left: 1.5rem;
            flex-shrink: 0;
        }

        .ultra-glossary h4 {
            font-size: 1rem;
            font-weight: bold;
            margin-bottom: 1rem;
            color: #e0e7ff;
            text-align: center;
            border-bottom: 1px solid #a855f7;
            padding-bottom: 0.5rem;
        }

        .glossary-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .glossary-section {
            margin-bottom: 0.75rem;
        }

        .glossary-section:last-child {
            margin-bottom: 0;
        }

        .glossary-title {
            font-weight: 600;
            font-size: 0.7rem;
            color: #ddd6fe;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-align: center;
            border-bottom: 1px solid rgba(168, 85, 247, 0.3);
            padding-bottom: 0.25rem;
        }

        .glossary-item {
            margin-bottom: 0.35rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .glossary-symbol {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #fbbf24;
            min-width: 2rem;
            font-size: 0.85rem;
            text-align: center;
        }

        .glossary-description {
            font-size: 0.65rem;
            color: #e0e7ff;
            flex: 1;
        }

        /* Container for premise display and glossary */
        .premise-with-glossary {
            display: flex;
            align-items: center;
            gap: 1.5rem;
        }

        /* Adjust premise box size for better balance */
        .premise-display-box.ultra-box {
            background: #7c3aed;
            border-color: #6d28d9;
            width: 700px;
            height: 400px;
        }

        .premise-text-only {
            text-align: center;
            width: 100%;
            max-width: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .premise-text-only div {
            margin-bottom: 0.7rem;
            white-space: nowrap;
            overflow: visible;
            text-overflow: clip;
            width: 100%;
            text-align: center;
            font-size: 2.1rem;
            font-weight: 600;
            line-height: 1.2;
            letter-spacing: 0.01em;
        }

        .advanced-box .premise-text-only div {
            font-size: 2rem;
            line-height: 1.3;
            margin-bottom: 0.7rem;
            white-space: normal;
            word-wrap: break-word;
        }

        .premise-text-only div:last-child {
            margin-bottom: 0;
        }

        /* Button Styles */
        .btn {
            padding: 0.75rem 2rem;
            border: none;
            border-radius: 0.5rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background: #2563eb;
            color: white;
        }

        .btn-primary:hover {
            background: #1d4ed8;
        }

        .btn-secondary {
            background: #6b7280;
            color: white;
        }

        .btn-secondary:hover {
            background: #4b5563;
        }

        .btn-danger {
            background: #dc2626;
            color: white;
        }

        .btn-danger:hover {
            background: #b91c1c;
        }

        /* Feedback and Status */
        .feedback {
            padding: 0.75rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .feedback.correct {
            background: #dcfce7;
            color: #166534;
        }

        .feedback.incorrect {
            background: #fef2f2;
            color: #991b1b;
        }

        .building-history {
            padding: 0.75rem;
            background: #f3f4f6;
            color: #6b7280;
            border-radius: 0.5rem;
            font-size: 0.875rem;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
        }

        .results-panel {
            background: #f0fdf4;
            padding: 1rem;
            border-radius: 0.5rem;
            max-width: 28rem;
            margin: 0 auto;
        }

        .score-detail {
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
        }

        .hidden {
            display: none;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        /* Mobile and Tablet Styles */
        @media (max-width: 1024px) {
            .header {
                flex-direction: column;
                gap: 1rem;
                text-align: center;
            }
            
            .header-right {
                align-items: center;
                width: 100%;
            }

            .mode-options {
                max-width: 100%;
                padding: 0 1rem;
            }

            .mode-card {
                padding: 1.5rem;
            }

            .setup-controls {
                max-width: 100%;
                padding: 0 1rem;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 1rem;
            }

            .container {
                max-width: 100%;
            }

            .card {
                padding: 1rem;
            }

            .title h1 {
                font-size: 1.5rem;
            }

            .mode-card h3 {
                font-size: 1.25rem;
            }

            .mode-card p {
                font-size: 0.8rem;
            }

            .mode-card {
                padding: 1.25rem;
            }

            .game-layout, .single-task-container, .relational-layout {
                flex-direction: column;
                gap: 2rem;
                padding: 1rem;
                min-height: auto;
            }
            
            .side-control, .single-task-controls, .relational-controls {
                flex-direction: row;
                justify-content: center;
                flex: auto;
                min-height: auto;
                gap: 2rem;
            }

            .side-control .spatial-btn,
            .side-control .relational-btn,
            .single-task-controls .single-task-btn,
            .relational-controls .single-task-btn {
                width: 140px;
                height: 140px;
                touch-action: manipulation;
                -webkit-tap-highlight-color: transparent;
            }

            .premise-display-area {
                width: 100%;
                display: flex;
                justify-content: center;
                margin-top: 1rem;
            }

            .premise-with-glossary {
                flex-direction: column;
                gap: 1.5rem;
                width: 100%;
                align-items: center;
            }

            .grid-cell {
                width: 100px;
                height: 100px;
                padding: 0.5rem;
            }
            
            .premise-text {
                font-size: calc(var(--premise-font-size, 1.2rem) * 0.75);
                line-height: 1.2;
            }

            .premise-display-box {
                width: 95vw;
                max-width: 400px;
                height: 300px;
                padding: 1rem;
            }

            .premise-display-box.advanced-box,
            .premise-display-box.ultra-box {
                width: 95vw;
                max-width: 400px;
                height: 350px;
            }

            .premise-text-only div {
                font-size: 1rem;
                line-height: 1.3;
                margin-bottom: 0.5rem;
                white-space: normal;
                word-break: break-word;
            }

            .ultra-glossary {
                width: 95vw;
                max-width: 350px;
                margin-left: 0;
                padding: 1rem;
                font-size: 0.7rem;
            }

            .glossary-grid {
                grid-template-columns: 1fr;
                gap: 0.75rem;
            }

            .glossary-symbol {
                min-width: 1.5rem;
                font-size: 0.8rem;
            }

            .glossary-description {
                font-size: 0.6rem;
            }

            .advanced-layout, .relational-layout {
                margin-left: 0;
                padding-left: 0;
                justify-content: center;
            }

            .relational-controls {
                position: static;
                left: auto;
            }

            .controls {
                flex-direction: column;
                gap: 1rem;
                padding: 0 1rem;
            }

            .btn {
                padding: 1rem 2rem;
                font-size: 1rem;
                min-height: 48px;
                touch-action: manipulation;
                -webkit-tap-highlight-color: transparent;
            }

            .score-display {
                font-size: 0.8rem;
                text-align: center;
            }

            .settings-display {
                font-size: 0.7rem;
                text-align: center;
                max-width: 100%;
            }

            .feedback {
                font-size: 0.8rem;
                padding: 0.5rem;
            }

            .building-history {
                font-size: 0.8rem;
                padding: 0.5rem;
            }

            .instructions {
                font-size: 0.8rem;
                padding: 0 1rem;
                text-align: left;
            }

            .results-panel {
                max-width: 100%;
                padding: 0.75rem;
            }

            .score-detail {
                font-size: 0.8rem;
                margin-bottom: 0.75rem;
            }
        }

        /* Small Mobile Phones */
        @media (max-width: 480px) {
            .title h1 {
                font-size: 1.25rem;
            }

            .title span {
                font-size: 1.5rem;
            }

            .mode-card {
                padding: 1rem;
            }

            .mode-card h3 {
                font-size: 1.1rem;
            }

            .game-layout, .single-task-container, .relational-layout {
                gap: 1.5rem;
                padding: 0.5rem;
            }

            .side-control .spatial-btn,
            .side-control .relational-btn,
            .single-task-controls .single-task-btn,
            .relational-controls .single-task-btn {
                width: 120px;
                height: 120px;
            }

            .btn-title {
                font-size: 1.1rem;
            }

            .btn-key {
                font-size: 0.8rem;
            }

            .grid-cell {
                width: 80px;
                height: 80px;
                padding: 0.25rem;
            }

            .premise-text {
                font-size: calc(var(--premise-font-size, 1.2rem) * 0.6);
            }

            .premise-display-box {
                width: 95vw;
                max-width: 320px;
                height: 250px;
                padding: 0.75rem;
            }

            .premise-display-box.advanced-box,
            .premise-display-box.ultra-box {
                height: 280px;
            }

            .premise-text-only div {
                font-size: 0.9rem;
            }

            .ultra-glossary {
                width: 95vw;
                max-width: 300px;
                padding: 0.75rem;
                font-size: 0.65rem;
            }

            .glossary-symbol {
                min-width: 1.25rem;
                font-size: 0.75rem;
            }

            .glossary-description {
                font-size: 0.55rem;
            }
        }

        /* Landscape Mobile */
        @media (max-width: 896px) and (orientation: landscape) {
            .game-layout, .single-task-container, .relational-layout {
                flex-direction: row;
                gap: 1rem;
                min-height: auto;
                align-items: center;
            }

            .side-control, .single-task-controls, .relational-controls {
                flex-direction: column;
                gap: 1rem;
            }

            .side-control .spatial-btn,
            .side-control .relational-btn,
            .single-task-controls .single-task-btn,
            .relational-controls .single-task-btn {
                width: 100px;
                height: 100px;
            }

            .grid-cell {
                width: 60px;
                height: 60px;
            }

            .premise-display-box {
                height: 200px;
            }

            .premise-display-box.advanced-box,
            .premise-display-box.ultra-box {
                height: 220px;
            }

            .premise-with-glossary {
                flex-direction: row;
                gap: 1rem;
            }

            .ultra-glossary {
                width: 200px;
                max-width: 200px;
                font-size: 0.6rem;
            }
        }

        /* Touch-specific styles */
        .spatial-btn, .relational-btn, .advanced-btn, .single-task-btn, .btn {
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Prevent zoom on form inputs */
        input[type="range"] {
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="card">
            <div class="header">
                <div class="title">
                    <span style="font-size: 2rem;">🧠</span>
                    <h1>Relational-Spatial Dual N-Back</h1>
                </div>
                <div class="header-right">
                    <div id="scoreDisplay" class="score-display hidden"></div>
                    <div id="settingsDisplay" class="settings-display hidden"></div>
                </div>
            </div>

            <!-- Mode Selection Screen -->
            <div id="modeSelectionScreen" class="mode-selection-screen">
                <h2 style="font-size: 1.5rem; font-weight: 600; margin-bottom: 2rem;">Choose Your Game Mode</h2>
                <div class="mode-options">
                    <div class="mode-card" data-mode="ultra">
                        <h3>Ultra-N-Relational-Reasoning</h3>
                        <p>Extreme mathematical logic with advanced algebraic operators, modal logic, and temporal indices. For Ultra-Minds only. The ultimate test of abstract reasoning.</p>
                    </div>
                    <div class="mode-card" data-mode="advanced">
                        <h3>Advanced-N-Relational-Reasoning</h3>
                        <p>Ultra-complex logical reasoning with advanced mathematical and computational relationships. Track compatibility of sophisticated logical constructs across n-back trials.</p>
                    </div>
                    <div class="mode-card" data-mode="relational">
                        <h3>Relational N-Back</h3>
                        <p>Focus purely on logical reasoning. Analyze spatial relationships between entities across n-back trials. No grid navigation required.</p>
                    </div>
                    <div class="mode-card" data-mode="spatial">
                        <h3>Spatial N-Back</h3>
                        <p>Focus purely on spatial working memory. Track square positions in a 3×3 grid across n-back trials. Classic Jaeggi paradigm with extreme cognitive interference.</p>
                    </div>
                    <div class="mode-card" data-mode="dual">
                        <h3>Dual N-Back (Spatial + Relational)</h3>
                        <p>The ultimate challenge. Simultaneously track both spatial positions and logical relationships. Maximum cognitive load.</p>
                    </div>
                </div>
                <button id="continueToSetup" class="btn btn-primary" style="margin-top: 2rem;" disabled>
                    Continue to Setup →
                </button>
            </div>

            <!-- Setup Screen -->
            <div id="setupScreen" class="setup-screen hidden">
                <div id="setupContent"></div>
                <button id="startGameBtn" class="btn btn-primary" style="margin-top: 2rem;">
                    ▶ Start Game
                </button>
                <button id="backToModeBtn" class="btn btn-secondary" style="margin-top: 2rem; margin-left: 1rem;">
                    ← Back to Mode Selection
                </button>
            </div>

            <!-- Results Screen -->
            <div id="resultsScreen" class="results-screen hidden">
                <h2 style="font-size: 1.5rem; font-weight: bold; color: #16a34a; margin-bottom: 1.5rem;">Session Complete!</h2>
                <div class="results-panel">
                    <h3 style="font-weight: 600; margin-bottom: 0.5rem;">Final Scores</h3>
                    <div id="finalScores"></div>
                </div>
                <div style="margin-top: 2rem;">
                    <button id="newSessionBtn" class="btn btn-primary">
                        🔄 Start New Session
                    </button>
                    <button id="changeModeBtn" class="btn btn-secondary" style="margin-left: 1rem;">
                        ← Change Game Mode
                    </button>
                </div>
            </div>

            <!-- Game Screen -->
            <div id="gameScreen" class="game-screen hidden">
                <div id="gameContent"></div>
                <div class="controls">
                    <button id="pauseBtn" class="btn btn-secondary">
                        ⏸ Pause
                    </button>
                    <button id="resetBtn" class="btn btn-danger">
                        🔄 Reset
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game state
        let gameState = 'modeSelection'; // 'modeSelection', 'setup', 'playing', 'paused', 'results'
        let selectedMode = null; // 'ultra', 'advanced', 'relational', 'spatial', 'dual'
        let nBackLevel = 2;
        let premisesCount = 3;
        let maxTrials = 100;
        let trialSpeed = 4000;
        let currentTrial = 0;
        let positionHistory = [];
        let premisesHistory = [];
        let currentPosition = null;
        let currentPremises = null;
        let isPlaying = false;
        let spatialScore = { correct: 0, total: 0, actualMatches: 0, missedMatches: 0 };
        let relationalScore = { correct: 0, total: 0, actualMatches: 0, missedMatches: 0 };
        let awaitingResponse = false;
        let spatialResponseGiven = false;
        let relationalResponseGiven = false;
        let sessionComplete = false;
        let trialTimeout = null;
        
        // Cognitive interference settings for Spatial N-Back
        let useInterference = false;
        let interferenceStrength = 0; // Will increase as game progresses
        let fakePositions = [];
        let lastFakePositions = [];
        let interferenceTimeout = null;
        let interferenceFlashTimeout = null;
        let gridRotationTimeout = null;
        let interferenceSymbols = [];
        
        // Entity names for premises
        const ENTITY_NAMES = [
            'KIR', 'LUM', 'ZUN', 'NAT', 'DAW', 'RIB', 'PUG', 'NUZ',
            'QIC', 'NOL', 'XEN', 'TIQ', 'BIM', 'DAN', 'LAR', 'NEZ',
            'VEN', 'ZEQ', 'FOW', 'FEM', 'SAX', 'KAP', 'FIG', 'CIL',
            'BOS', 'PEV', 'LES', 'BEQ', 'DEF', 'CEQ', 'KAZ', 'MUC'
        ];

        // Ultra entity names for ultra reasoning mode (Greek letters and capitals)
        const ULTRA_ENTITY_NAMES = [
            'ψ', 'φ', 'β', 'κ', 'η', 'γ', 'ι', 'τ', 'υ', 'λ', 'θ', 'π', 'μ', 'ζ', 'ε', 'α', 'ξ', 'ν', 'ω', 'χ', 'δ',
            'ρ', 'σ', 'ο', // Additional Greek letters
            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M'
        ];

        // Advanced entity names for advanced reasoning mode
        const ADVANCED_ENTITY_NAMES = [
            'QOR', 'RAV', 'WEL', 'ZIN', 'BEX', 'FAX', 'NIV', 'LOM',
            'MUX', 'TEX', 'ZEP', 'VOR', 'GLX', 'HAZ', 'IXL', 'JOR',
            'KYV', 'NEX', 'OPT', 'PIQ', 'ROZ', 'SYN', 'TUV', 'UXY'
        ];

        // Interference symbols for spatial mode
        const INTERFERENCE_SYMBOLS = [
            '◆', '■', '▲', '●', '◇', '□', '△', '○', '★', '☆', '✱', '✶', 
            '♦', '♥', '♣', '♠', '✚', '✖', '✤', '✦', '✧', '✩', '✪', '✫'
        ];

        // DOM elements
        const modeSelectionScreen = document.getElementById('modeSelectionScreen');
        const setupScreen = document.getElementById('setupScreen');
        const gameScreen = document.getElementById('gameScreen');
        const resultsScreen = document.getElementById('resultsScreen');
        const scoreDisplay = document.getElementById('scoreDisplay');

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            bindModeSelectionEvents();
        });

        function bindModeSelectionEvents() {
            // Mode selection cards
            document.querySelectorAll('.mode-card').forEach(card => {
                card.addEventListener('click', () => {
                    // Remove previous selection
                    document.querySelectorAll('.mode-card').forEach(c => c.classList.remove('selected'));
                    // Select this card
                    card.classList.add('selected');
                    selectedMode = card.dataset.mode;
                    document.getElementById('continueToSetup').disabled = false;
                });
            });

            // Continue to setup button
            document.getElementById('continueToSetup').addEventListener('click', () => {
                if (selectedMode) {
                    showSetupScreen();
                }
            });
        }

        function showSetupScreen() {
            modeSelectionScreen.classList.add('hidden');
            setupScreen.classList.remove('hidden');
            gameState = 'setup';
            renderSetupScreen();
        }

        function renderSetupScreen() {
            const setupContent = document.getElementById('setupContent');
            
            let modeTitle = '';
            let modeDescription = '';
            
            if (selectedMode === 'ultra') {
                modeTitle = 'Ultra-N-Relational-Reasoning Setup';
                modeDescription = 'Configure your ultra-advanced mathematical logic n-back session.';
            } else if (selectedMode === 'advanced') {
                modeTitle = 'Advanced-N-Relational-Reasoning Setup';
                modeDescription = 'Configure your advanced relational reasoning n-back session.';
            } else if (selectedMode === 'relational') {
                modeTitle = 'Relational N-Back Setup';
                modeDescription = 'Configure your relational reasoning n-back session.';
            } else if (selectedMode === 'spatial') {
                modeTitle = 'Spatial N-Back Setup';
                modeDescription = 'Configure your spatial working memory n-back session.';
            } else if (selectedMode === 'dual') {
                modeTitle = 'Dual N-Back Setup';
                modeDescription = 'Configure your dual-task n-back session.';
            }

            let setupHTML = `
                <h2 style="font-size: 1.25rem; font-weight: 600; margin-bottom: 1.5rem;">${modeTitle}</h2>
                <div class="setup-controls">
                    <div class="control-group">
                        <label>N-Back Level: <span id="nBackValue">${nBackLevel}</span></label>
                        <input type="range" id="nBackLevel" min="1" max="15" value="${nBackLevel}">
                    </div>
            `;

            if (selectedMode === 'ultra' || selectedMode === 'advanced' || selectedMode === 'relational' || selectedMode === 'dual') {
                setupHTML += `
                    <div class="control-group">
                        <label>Statements per Trial: <span id="premisesValue">${premisesCount}</span></label>
                        <input type="range" id="premisesCount" min="1" max="5" value="${premisesCount}">
                    </div>
                `;
            }

            setupHTML += `
                    <div class="control-group">
                        <label>Session Length: <span id="maxTrialsValue">${maxTrials}</span> trials</label>
                        <input type="range" id="maxTrials" min="50" max="200" step="25" value="${maxTrials}">
                    </div>
                    <div class="control-group">
                        <label>Trial Duration: <span id="trialSpeedValue">${trialSpeed / 1000}</span>s</label>
                        <input type="range" id="trialSpeed" min="3000" max="8000" step="500" value="${trialSpeed}">
                    </div>
                </div>
                <div class="instructions" style="margin: 1.5rem auto;">
                    <p style="margin-bottom: 1rem;"><strong>${modeDescription}</strong></p>
            `;

            if (selectedMode === 'ultra') {
                setupHTML += `
                    <p style="margin-bottom: 0.5rem;"><strong>Your Task:</strong> Decode ultra-complex mathematical-logical expressions and determine compatibility with statements from ${nBackLevel} trials back.</p>
                    <p style="font-size: 0.75rem;">Each trial presents ${premisesCount} extreme algebraic statements with temporal indices, modal operators, and advanced mathematical notation. Press Enter if they're compatible with the statements from n trials back.</p>
                `;
            } else if (selectedMode === 'advanced') {
                setupHTML += `
                    <p style="margin-bottom: 0.5rem;"><strong>Your Task:</strong> Determine if the advanced logical statements are logically compatible with those from ${nBackLevel} trials back.</p>
                    <p style="font-size: 0.75rem;">Each trial presents ${premisesCount} complex computational-logical statements involving generators, mappings, and mathematical relationships. Press Enter if they're compatible with the statements from n trials back.</p>
                `;
            } else if (selectedMode === 'relational') {
                setupHTML += `
                    <p style="margin-bottom: 0.5rem;"><strong>Your Task:</strong> Determine if the premises are logically compatible with those from ${nBackLevel} trials back.</p>
                    <p style="font-size: 0.75rem;">Each trial presents ${premisesCount} relational premises about spatial relationships. Press Enter if they're compatible with the premises from n trials back.</p>
                `;
            } else if (selectedMode === 'spatial') {
                setupHTML += `
                    <p style="margin-bottom: 0.5rem;"><strong>Your Task:</strong> Track if the current square position matches the position from ${nBackLevel} trials back.</p>
                    <p style="font-size: 0.75rem;"><strong>Warning: This mode includes extreme cognitive interference.</strong> A square will light up briefly each trial. Press spacebar if it matches the position from n trials back.</p>
                    <p style="font-size: 0.75rem; color: #dc2626;">The grid will become increasingly disruptive, with distractions and visual noise designed to induce cognitive dissonance. Stay focused despite the interference.</p>
                `;
            } else if (selectedMode === 'dual') {
                setupHTML += `
                    <p style="margin-bottom: 0.5rem;"><strong>Spatial Task:</strong> Track if the current square position matches ${nBackLevel} trials back.</p>
                    <p style="margin-bottom: 0.5rem;"><strong>Relational Task:</strong> Determine if the premises are logically compatible with those from ${nBackLevel} trials back.</p>
                    <p style="font-size: 0.75rem;">Each active square contains ${premisesCount} relational premises. Track both the square position AND premise compatibility across trials.</p>
                `;
            }

            setupHTML += `</div>`;
            setupContent.innerHTML = setupHTML;

            bindSetupEvents();
        }

        function bindSetupEvents() {
            document.getElementById('nBackLevel').addEventListener('input', (e) => {
                nBackLevel = parseInt(e.target.value);
                document.getElementById('nBackValue').textContent = nBackLevel;
                renderSetupScreen(); // Re-render to update instructions
            });

            const premisesInput = document.getElementById('premisesCount');
            if (premisesInput) {
                premisesInput.addEventListener('input', (e) => {
                    premisesCount = parseInt(e.target.value);
                    document.getElementById('premisesValue').textContent = premisesCount;
                    renderSetupScreen(); // Re-render to update instructions
                });
            }

            document.getElementById('maxTrials').addEventListener('input', (e) => {
                maxTrials = parseInt(e.target.value);
                document.getElementById('maxTrialsValue').textContent = maxTrials;
            });

            document.getElementById('trialSpeed').addEventListener('input', (e) => {
                trialSpeed = parseInt(e.target.value);
                document.getElementById('trialSpeedValue').textContent = (trialSpeed / 1000);
            });

            document.getElementById('startGameBtn').addEventListener('click', startGame);
            document.getElementById('backToModeBtn').addEventListener('click', () => {
                setupScreen.classList.add('hidden');
                modeSelectionScreen.classList.remove('hidden');
                gameState = 'modeSelection';
            });
        }

        function startGame() {
            gameState = 'playing';
            isPlaying = true;
            currentTrial = 0;
            positionHistory = [];
            premisesHistory = [];
            spatialScore = { correct: 0, total: 0, actualMatches: 0, missedMatches: 0 };
            relationalScore = { correct: 0, total: 0, actualMatches: 0, missedMatches: 0 };
            spatialResponseGiven = false;
            relationalResponseGiven = false;
            sessionComplete = false;
            
            // Reset interference settings
            useInterference = selectedMode === 'spatial';
            interferenceStrength = 0;
            fakePositions = [];
            lastFakePositions = [];
            clearAllInterferenceTimeouts();

            setupScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');

            renderGameScreen();
            updateSettingsDisplay();
            
            setTimeout(() => startNewTrial(), 1000);
        }
        
        function clearAllInterferenceTimeouts() {
            // Clear all interference-related timeouts
            if (interferenceTimeout) {
                clearTimeout(interferenceTimeout);
                interferenceTimeout = null;
            }
            if (interferenceFlashTimeout) {
                clearTimeout(interferenceFlashTimeout);
                interferenceFlashTimeout = null;
            }
            if (gridRotationTimeout) {
                clearTimeout(gridRotationTimeout);
                gridRotationTimeout = null;
            }
        }

        function renderGameScreen() {
            const gameContent = document.getElementById('gameContent');
            
            if (selectedMode === 'dual') {
                gameContent.innerHTML = `
                    <div class="game-layout">
                        <div class="side-control">
                            <button id="spatialMatchBtn" class="spatial-btn">
                                <div class="btn-title">Spatial</div>
                                <div class="btn-key">spacebar</div>
                            </button>
                            <div id="spatialFeedback" class="feedback hidden"></div>
                            <div id="spatialHistory" class="building-history hidden">Building history...</div>
                        </div>
                        <div class="grid-container">
                            <div id="spatialGrid" class="spatial-grid"></div>
                        </div>
                        <div class="side-control">
                            <button id="relationalMatchBtn" class="relational-btn">
                                <div class="btn-title">Relational</div>
                                <div class="btn-key">Enter</div>
                            </button>
                            <div id="relationalFeedback" class="feedback hidden"></div>
                            <div id="relationalHistory" class="building-history hidden">Building history...</div>
                        </div>
                    </div>
                `;
                createGrid('spatialGrid');
            } else if (selectedMode === 'spatial') {
                gameContent.innerHTML = `
                    <div class="single-task-container">
                        <div class="single-task-controls">
                            <button id="spatialOnlyBtn" class="single-task-btn spatial-btn">
                                <div class="btn-title">Match</div>
                                <div class="btn-key">spacebar</div>
                            </button>
                            <div id="spatialOnlyFeedback" class="feedback hidden"></div>
                            <div id="spatialOnlyHistory" class="building-history hidden">Building history...</div>
                        </div>
                        <div class="grid-container">
                            <div id="spatialOnlyGrid" class="spatial-grid"></div>
                            <div class="interference-container" id="interferenceContainer"></div>
                        </div>
                    </div>
                `;
                createGrid('spatialOnlyGrid');
                // Setup initial grid interference elements
                setupGridInterference();
            } else if (selectedMode === 'relational' || selectedMode === 'advanced' || selectedMode === 'ultra') {
                const btnTitle = 'Match';
                let modeClass = 'relational';
                let layoutClass = '';
                let boxClass = '';
                
                if (selectedMode === 'ultra') {
                    modeClass = 'advanced';
                    layoutClass = 'advanced-layout ultra-layout';
                    boxClass = 'ultra-box';
                } else if (selectedMode === 'advanced') {
                    modeClass = 'advanced';
                    layoutClass = 'advanced-layout';
                    boxClass = 'advanced-box';
                }
                
                gameContent.innerHTML = `
                    <div class="relational-layout ${layoutClass}">
                        <div class="relational-controls">
                            <button id="relationalOnlyBtn" class="single-task-btn ${modeClass}-btn relational-btn">
                                <div class="btn-title">${btnTitle}</div>
                                <div class="btn-key">Enter</div>
                            </button>
                            <div id="relationalOnlyFeedback" class="feedback hidden"></div>
                            <div id="relationalOnlyHistory" class="building-history hidden">Building history...</div>
                        </div>
                        <div class="premise-display-area">
                            ${selectedMode === 'ultra' ? `
                            <div class="premise-with-glossary">
                                <div id="premiseDisplay" class="premise-display-box ${boxClass}"></div>
                                <div id="ultraGlossary" class="ultra-glossary">
                                    <h4>🧠 Ultra Symbols</h4>
                                    
                                    <div class="glossary-grid">
                                        <div class="glossary-section">
                                            <div class="glossary-title">Time Index</div>
                                            <div class="glossary-item">
                                                <span class="glossary-symbol">t</span>
                                                <span class="glossary-description">current time</span>
                                            </div>
                                            <div class="glossary-item">
                                                <span class="glossary-symbol">k-x</span>
                                                <span class="glossary-description">x steps back</span>
                                            </div>
                                        </div>

                                        <div class="glossary-section">
                                            <div class="glossary-title">Greek Entities</div>
                                            <div class="glossary-item">
                                                <span class="glossary-symbol">ψ φ β κ η</span>
                                                <span class="glossary-description">entities</span>
                                            </div>
                                            <div class="glossary-item">
                                                <span class="glossary-symbol">γ ι τ υ λ</span>
                                                <span class="glossary-description">entities</span>
                                            </div>
                                            <div class="glossary-item">
                                                <span class="glossary-symbol">θ π μ ζ ε</span>
                                                <span class="glossary-description">entities</span>
                                            </div>
                                            <div class="glossary-item">
                                                <span class="glossary-symbol">α ξ ν ω χ δ</span>
                                                <span class="glossary-description">entities</span>
                                            </div>
                                        </div>

                                        <div class="glossary-section">
                                            <div class="glossary-title">Modal Logic</div>
                                            <div class="glossary-item">
                                                <span class="glossary-symbol">□</span>
                                                <span class="glossary-description">necessity</span>
                                            </div>
                                            <div class="glossary-item">
                                                <span class="glossary-symbol">◇</span>
                                                <span class="glossary-description">possibility</span>
                                            </div>
                                            <div class="glossary-item">
                                                <span class="glossary-symbol">◻</span>
                                                <span class="glossary-description">dual necessity</span>
                                            </div>
                                            <div class="glossary-item">
                                                <span class="glossary-symbol">◉</span>
                                                <span class="glossary-description">contingency</span>
                                            </div>
                                        </div>

                                        <div class="glossary-section">
                                            <div class="glossary-title">Algebraic</div>
                                            <div class="glossary-item">
                                                <span class="glossary-symbol">⊗</span>
                                                <span class="glossary-description">tensor expansion</span>
                                            </div>
                                            <div class="glossary-item">
                                                <span class="glossary-symbol">⋄</span>
                                                <span class="glossary-description">permutation</span>
                                            </div>
                                            <div class="glossary-item">
                                                <span class="glossary-symbol">◦</span>
                                                <span class="glossary-description">composition</span>
                                            </div>
                                            <div class="glossary-item">
                                                <span class="glossary-symbol">∘</span>
                                                <span class="glossary-description">alt composition</span>
                                            </div>
                                            <div class="glossary-item">
                                                <span class="glossary-symbol">⊕</span>
                                                <span class="glossary-description">vector add</span>
                                            </div>
                                            <div class="glossary-item">
                                                <span class="glossary-symbol">⊖</span>
                                                <span class="glossary-description">vector subtract</span>
                                            </div>
                                            <div class="glossary-item">
                                                <span class="glossary-symbol">≺ ≻</span>
                                                <span class="glossary-description">precedence</span>
                                            </div>
                                        </div>

                                        <div class="glossary-section">
                                            <div class="glossary-title">Other</div>
                                            <div class="glossary-item">
                                                <span class="glossary-symbol">†</span>
                                                <span class="glossary-description">inverse</span>
                                            </div>
                                            <div class="glossary-item">
                                                <span class="glossary-symbol">( )</span>
                                                <span class="glossary-description">scope/grouping</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            ` : `
                            <div id="premiseDisplay" class="premise-display-box ${boxClass}"></div>
                            `}
                        </div>
                    </div>
                `;
            }

            bindGameEvents();
            updateFontSizing();
        }
        
        function setupGridInterference() {
            // Create and set up interference container if this is spatial mode
            if (selectedMode === 'spatial') {
                const container = document.getElementById('interferenceContainer');
                if (container) {
                    // Clear previous interference elements
                    container.innerHTML = '';
                    interferenceSymbols = [];
                    
                    // Create interference overlay for all grid cells
                    document.querySelectorAll('#spatialOnlyGrid .grid-cell').forEach((cell, index) => {
                        const overlay = document.createElement('div');
                        overlay.className = 'interference-overlay';
                        overlay.id = `overlay-${index}`;
                        cell.appendChild(overlay);
                    });
                    
                    // Create floating interference symbols
                    for (let i = 0; i < 15; i++) {
                        const symbol = document.createElement('div');
                        symbol.className = 'interference-symbol';
                        symbol.textContent = INTERFERENCE_SYMBOLS[Math.floor(Math.random() * INTERFERENCE_SYMBOLS.length)];
                        symbol.style.top = `${Math.random() * 100}%`;
                        symbol.style.left = `${Math.random() * 100}%`;
                        symbol.style.opacity = '0';
                        symbol.style.color = getRandomColor(0.6);
                        container.appendChild(symbol);
                        interferenceSymbols.push(symbol);
                    }
                }
            }
        }
        
        function getRandomColor(opacity = 1) {
            const colors = [
                `rgba(239, 68, 68, ${opacity})`,    // red
                `rgba(16, 185, 129, ${opacity})`,   // green
                `rgba(59, 130, 246, ${opacity})`,   // blue
                `rgba(236, 72, 153, ${opacity})`,   // pink
                `rgba(139, 92, 246, ${opacity})`,   // purple
                `rgba(245, 158, 11, ${opacity})`    // amber
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        function createGrid(gridId) {
            const grid = document.getElementById(gridId);
            grid.innerHTML = '';
            for (let i = 0; i < 9; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.id = `${gridId}-cell-${i}`;
                grid.appendChild(cell);
            }
        }

        function updateFontSizing() {
            // Adjusted font sizes for larger grid cells (280x280px)
            if (premisesCount <= 2) {
                document.documentElement.style.setProperty('--premise-font-size', '1.6rem');
                document.documentElement.style.setProperty('--premise-spacing', '0.8rem');
            } else if (premisesCount === 3) {
                document.documentElement.style.setProperty('--premise-font-size', '1.4rem');
                document.documentElement.style.setProperty('--premise-spacing', '0.7rem');
            } else if (premisesCount === 4) {
                document.documentElement.style.setProperty('--premise-font-size', '1.2rem');
                document.documentElement.style.setProperty('--premise-spacing', '0.6rem');
            } else {
                document.documentElement.style.setProperty('--premise-font-size', '1.1rem');
                document.documentElement.style.setProperty('--premise-spacing', '0.5rem');
            }
        }

        function bindGameEvents() {
            // Response buttons
            const spatialMatchBtn = document.getElementById('spatialMatchBtn');
            if (spatialMatchBtn) {
                spatialMatchBtn.addEventListener('click', () => {
                    if (!spatialResponseGiven) handleSpatialResponse(true);
                });
            }

            const spatialOnlyBtn = document.getElementById('spatialOnlyBtn');
            if (spatialOnlyBtn) {
                spatialOnlyBtn.addEventListener('click', () => {
                    if (!spatialResponseGiven) handleSpatialResponse(true);
                });
            }

            const relationalMatchBtn = document.getElementById('relationalMatchBtn');
            if (relationalMatchBtn) {
                relationalMatchBtn.addEventListener('click', () => {
                    if (!relationalResponseGiven) handleRelationalResponse(true);
                });
            }

            const relationalOnlyBtn = document.getElementById('relationalOnlyBtn');
            if (relationalOnlyBtn) {
                relationalOnlyBtn.addEventListener('click', () => {
                    if (!relationalResponseGiven) handleRelationalResponse(true);
                });
            }

            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                if (gameState === 'playing' && awaitingResponse && currentTrial > nBackLevel) {
                    if (e.code === 'Space' && (selectedMode === 'spatial' || selectedMode === 'dual') && !spatialResponseGiven) {
                        e.preventDefault();
                        handleSpatialResponse(true);
                    } else if (e.code === 'Enter' && (selectedMode === 'relational' || selectedMode === 'dual' || selectedMode === 'advanced' || selectedMode === 'ultra') && !relationalResponseGiven) {
                        e.preventDefault();
                        handleRelationalResponse(true);
                    }
                }
            });

            // Control buttons
            document.getElementById('pauseBtn').addEventListener('click', togglePause);
            document.getElementById('resetBtn').addEventListener('click', resetGame);
        }

        function generateRandomPosition() {
            return Math.floor(Math.random() * 9);
        }

        function generatePremises() {
            if (selectedMode === 'ultra') {
                return generateUltraPremises();
            } else if (selectedMode === 'advanced') {
                return generateAdvancedPremises();
            } else {
                return generateBasicPremises();
            }
        }

        function generateBasicPremises() {
            // Sophisticated premise generation with controlled match rate
            const shouldMatch = currentTrial > nBackLevel && Math.random() < 0.25; // 25% match rate
            
            if (shouldMatch && premisesHistory.length >= nBackLevel) {
                // Generate premises that are logically compatible with n-back premises
                const nBackPremises = premisesHistory[currentTrial - nBackLevel - 1];
                return generateCompatiblePremises(nBackPremises);
            } else {
                // Generate new random premises
                return generateRandomPremises();
            }
        }
        
        function generateRandomPremises() {
            const entities = [];
            while (entities.length < premisesCount + 2) {
                const entity = ENTITY_NAMES[Math.floor(Math.random() * ENTITY_NAMES.length)];
                if (!entities.includes(entity)) {
                    entities.push(entity);
                }
            }

            const relationshipTypes = getRelationshipTypes();
            const premises = [];
            
            for (let i = 0; i < premisesCount; i++) {
                const entity1 = entities[i];
                const entity2 = entities[i + 1];
                const relationship = relationshipTypes[Math.floor(Math.random() * relationshipTypes.length)];
                premises.push(`${entity1} is ${relationship} of ${entity2}`);
            }

            return premises;
        }
        
        function generateCompatiblePremises(referencePremises) {
            // Generate premises that are logically compatible with reference premises
            const transformationType = Math.floor(Math.random() * 6);
            
            switch (transformationType) {
                case 0: // Entity substitution (isomorphism)
                    return generateIsomorphicPremises(referencePremises);
                case 1: // Spatial rotation
                    return generateRotatedPremises(referencePremises);
                case 2: // Spatial reflection
                    return generateReflectedPremises(referencePremises);
                case 3: // Translation (all entities shifted)
                    return generateTranslatedPremises(referencePremises);
                case 4: // Partial structure preservation
                    return generatePartiallyCompatiblePremises(referencePremises);
                case 5: // Logical equivalence transformation
                    return generateLogicallyEquivalentPremises(referencePremises);
                default:
                    return generateIsomorphicPremises(referencePremises);
            }
        }
        
        function generateIsomorphicPremises(referencePremises) {
            // Same structure, different entities
            const entityMapping = new Map();
            const availableEntities = [...ENTITY_NAMES];
            
            // Extract entities from reference premises
            const referenceEntities = new Set();
            referencePremises.forEach(premise => {
                const match = premise.match(/(\w+)\s+is\s+.*?\s+of\s+(\w+)/);
                if (match) {
                    referenceEntities.add(match[1]);
                    referenceEntities.add(match[2]);
                }
            });
            
            // Create new entity mapping
            referenceEntities.forEach(entity => {
                let newEntity;
                do {
                    const idx = Math.floor(Math.random() * availableEntities.length);
                    newEntity = availableEntities[idx];
                    availableEntities.splice(idx, 1);
                } while (entityMapping.has(newEntity));
                
                entityMapping.set(entity, newEntity);
            });
            
            // Transform premises with new entities
            return referencePremises.map(premise => {
                let transformed = premise;
                entityMapping.forEach((newEntity, oldEntity) => {
                    const regex = new RegExp(`\\b${oldEntity}\\b`, 'g');
                    transformed = transformed.replace(regex, newEntity);
                });
                return transformed;
            });
        }
        
        function generateRotatedPremises(referencePremises) {
            // Rotate spatial relationships (North->East, East->South, etc.)
            const rotationMap = {
                'North': 'East',
                'East': 'South',
                'South': 'West',
                'West': 'North'
            };
            
            return referencePremises.map(premise => {
                let rotated = premise;
                Object.entries(rotationMap).forEach(([from, to]) => {
                    rotated = rotated.replace(new RegExp(from, 'g'), `TEMP_${to}`);
                });
                // Replace temp markers
                rotated = rotated.replace(/TEMP_/g, '');
                
                // Also swap some entities to make it less obvious
                if (Math.random() < 0.5) {
                    const match = premise.match(/(\w+)\s+is\s+(.*?)\s+of\s+(\w+)/);
                    if (match) {
                        const [, entity1, relation, entity2] = match;
                        // Randomly pick new entities
                        const newEntity1 = ENTITY_NAMES[Math.floor(Math.random() * ENTITY_NAMES.length)];
                        const newEntity2 = ENTITY_NAMES[Math.floor(Math.random() * ENTITY_NAMES.length)];
                        rotated = rotated.replace(entity1, newEntity1).replace(entity2, newEntity2);
                    }
                }
                
                return rotated;
            });
        }
        
        function generateReflectedPremises(referencePremises) {
            // Reflect spatial relationships (North<->South, East<->West)
            const reflectionMap = {
                'North': 'South',
                'South': 'North',
                'East': 'West',
                'West': 'East',
                'above': 'below',
                'below': 'above'
            };
            
            return referencePremises.map(premise => {
                let reflected = premise;
                Object.entries(reflectionMap).forEach(([from, to]) => {
                    reflected = reflected.replace(new RegExp(from, 'g'), `TEMP_${to}`);
                });
                reflected = reflected.replace(/TEMP_/g, '');
                
                // Change some entities
                if (Math.random() < 0.7) {
                    reflected = randomlyChangeEntities(reflected);
                }
                
                return reflected;
            });
        }
        
        function generateTranslatedPremises(referencePremises) {
            // All relationships stay the same, but with systematic entity substitution
            const entityMap = createSystematicEntityMapping(referencePremises);
            
            return referencePremises.map(premise => {
                let translated = premise;
                entityMap.forEach((newEntity, oldEntity) => {
                    const regex = new RegExp(`\\b${oldEntity}\\b`, 'g');
                    translated = translated.replace(regex, newEntity);
                });
                return translated;
            });
        }
        
        function generatePartiallyCompatiblePremises(referencePremises) {
            // Keep some structure, change others
            const numToKeep = Math.ceil(premisesCount * 0.6); // Keep 60% of structure
            const indicesToKeep = new Set();
            
            while (indicesToKeep.size < numToKeep) {
                indicesToKeep.add(Math.floor(Math.random() * premisesCount));
            }
            
            return referencePremises.map((premise, idx) => {
                if (indicesToKeep.has(idx)) {
                    // Keep structure but change entities
                    return randomlyChangeEntities(premise);
                } else {
                    // Generate new premise that fits with kept ones
                    return generateCoherentPremise(referencePremises, idx);
                }
            });
        }
        
        function generateLogicallyEquivalentPremises(referencePremises) {
            // Use logical equivalences (e.g., "A is north of B" = "B is south of A")
            return referencePremises.map(premise => {
                if (Math.random() < 0.5) {
                    // Invert the relationship
                    const match = premise.match(/(\w+)\s+is\s+(.*?)\s+of\s+(\w+)/);
                    if (match) {
                        const [, entity1, relation, entity2] = match;
                        const invertedRelation = invertRelationship(relation);
                        if (invertedRelation) {
                            return `${entity2} is ${invertedRelation} of ${entity1}`;
                        }
                    }
                }
                // Otherwise, use entity substitution
                return randomlyChangeEntities(premise);
            });
        }
        
        function createSystematicEntityMapping(premises) {
            const entityMap = new Map();
            const usedEntities = new Set();
            
            // Extract all entities
            const entities = new Set();
            premises.forEach(premise => {
                const match = premise.match(/(\w+)\s+is\s+.*?\s+of\s+(\w+)/);
                if (match) {
                    entities.add(match[1]);
                    entities.add(match[2]);
                }
            });
            
            // Create systematic mapping
            entities.forEach(entity => {
                let newEntity;
                do {
                    newEntity = ENTITY_NAMES[Math.floor(Math.random() * ENTITY_NAMES.length)];
                } while (usedEntities.has(newEntity));
                
                usedEntities.add(newEntity);
                entityMap.set(entity, newEntity);
            });
            
            return entityMap;
        }
        
        function randomlyChangeEntities(premise) {
            const match = premise.match(/(\w+)\s+is\s+(.*?)\s+of\s+(\w+)/);
            if (match) {
                const [, entity1, relation, entity2] = match;
                const newEntity1 = ENTITY_NAMES[Math.floor(Math.random() * ENTITY_NAMES.length)];
                let newEntity2;
                do {
                    newEntity2 = ENTITY_NAMES[Math.floor(Math.random() * ENTITY_NAMES.length)];
                } while (newEntity2 === newEntity1);
                
                return `${newEntity1} is ${relation} of ${newEntity2}`;
            }
            return premise;
        }
        
        function generateCoherentPremise(allPremises, currentIdx) {
            // Generate a premise that's coherent with the structure
            const entities = new Set();
            allPremises.forEach(premise => {
                const match = premise.match(/(\w+)\s+is\s+.*?\s+of\s+(\w+)/);
                if (match) {
                    entities.add(match[1]);
                    entities.add(match[2]);
                }
            });
            
            const entityArray = Array.from(entities);
            const entity1 = entityArray[Math.floor(Math.random() * entityArray.length)];
            let entity2;
            do {
                entity2 = entityArray[Math.floor(Math.random() * entityArray.length)];
            } while (entity2 === entity1);
            
            const relationships = getRelationshipTypes();
            const relation = relationships[Math.floor(Math.random() * relationships.length)];
            
            return `${entity1} is ${relation} of ${entity2}`;
        }
        
        function invertRelationship(relation) {
            const inversions = {
                'one level above': 'one level below',
                'one level below': 'one level above',
                'two levels above': 'two levels below',
                'two levels below': 'two levels above',
                'one step North': 'one step South',
                'one step South': 'one step North',
                'one step East': 'one step West',
                'one step West': 'one step East',
                'two steps North': 'two steps South',
                'two steps South': 'two steps North',
                'two steps East': 'two steps West',
                'two steps West': 'two steps East'
            };
            
            return inversions[relation] || null;
        }
        
        function getRelationshipTypes() {
            return [
                'one level above', 'one level below',
                'two levels above', 'two levels below',
                'three levels above', 'three levels below',
                'on the same level',
                'one step North', 'one step South',
                'one step East', 'one step West',
                'two steps North', 'two steps South',
                'two steps East', 'two steps West',
                'three steps North', 'three steps South',
                'three steps East', 'three steps West',
                'one diagonal Northeast', 'one diagonal Northwest',
                'one diagonal Southeast', 'one diagonal Southwest'
            ];
        }

        function generateUltraPremises() {
            const entities = [];
            while (entities.length < premisesCount + 3) {
                const entity = ULTRA_ENTITY_NAMES[Math.floor(Math.random() * ULTRA_ENTITY_NAMES.length)];
                if (!entities.includes(entity)) {
                    entities.push(entity);
                }
            }

            // Algebraic operators
            const algebraicOps = ['⊗', '⋄', '◦', '∘', '⊕', '⊖'];
            // Modal operators  
            const modalOps = ['□', '◇', '◻', '◉'];
            // Precedence operators
            const precedenceOps = ['≺', '≻'];
            
            const premises = [];
            for (let i = 0; i < premisesCount; i++) {
                const entity1 = entities[i];
                const entity2 = entities[i + 1];
                const entity3 = entities[(i + 2) % entities.length];
                
                // Generate wider range of time indices (k-1 to k-10) regardless of n-back level
                const timeIndex1 = Math.floor(Math.random() * 10) + 1; // k-1 to k-10
                const timeIndex2 = Math.floor(Math.random() * 10) + 1; // k-1 to k-10
                const timeIndex3 = Math.floor(Math.random() * 10) + 1; // k-1 to k-10
                
                // Choose operators
                const modalOp = modalOps[Math.floor(Math.random() * modalOps.length)];
                const algebraicOp1 = algebraicOps[Math.floor(Math.random() * algebraicOps.length)];
                const algebraicOp2 = algebraicOps[Math.floor(Math.random() * algebraicOps.length)];
                const precedenceOp = precedenceOps[Math.floor(Math.random() * precedenceOps.length)];
                
                // More complex patterns with the new k-x notation
                const patterns = [
                    // Pattern 1: entity_t modal_op algebraic_op ((entity_{k-x} algebraic_op entity_{k-x}†))
                    `${entity1}_t ${modalOp}${algebraicOp1}((${entity2}_{k-${timeIndex1}} ${algebraicOp2} ${entity3}_{k-${timeIndex2}}†))`,
                    
                    // Pattern 2: entity_t modal_op algebraic_op (entity_{k-x} algebraic_op (entity_{k-x}†))  
                    `${entity1}_t ${modalOp}${algebraicOp1}(${entity2}_{k-${timeIndex1}} ${algebraicOp2} (${entity3}_{k-${timeIndex2}}†))`,
                    
                    // Pattern 3: with precedence operators
                    `${entity1}_t ${modalOp}${precedenceOp}((${entity2}_{k-${timeIndex1}} ${algebraicOp1} ${entity3}_{k-${timeIndex2}}†))`,
                    
                    // Pattern 4: precedence with parentheses
                    `${entity1}_t ${modalOp}${precedenceOp}(${entity2}_{k-${timeIndex1}} ${algebraicOp1} (${entity3}_{k-${timeIndex2}}†))`,
                    
                    // Pattern 5: double parentheses with precedence
                    `${entity1}_t ${modalOp}${algebraicOp1}((${entity2}_{k-${timeIndex1}} ${precedenceOp} ${entity3}_{k-${timeIndex2}}†))`,
                    
                    // Pattern 6: triple entity pattern
                    `${entity1}_t ${modalOp}${algebraicOp1}((${entity2}_{k-${timeIndex1}} ${algebraicOp2} ${entity3}_{k-${timeIndex2}}†) ${precedenceOp} (${entities[(i + 3) % entities.length]}_{k-${timeIndex3}}†))`,
                    
                    // Pattern 7: nested modal operators
                    `${entity1}_t ${modalOp}${algebraicOp1}(${entity2}_{k-${timeIndex1}} ${precedenceOp} (${entity3}_{k-${timeIndex2}}†))`,
                    
                    // Pattern 8: complex nesting
                    `${entity1}_t ${modalOp}${algebraicOp1}((${entity2}_{k-${timeIndex1}} ${algebraicOp2} (${entity3}_{k-${timeIndex2}}†)))`,
                    
                    // Pattern 9: alternative composition
                    `${entity1}_t ${modalOp}∘((${entity2}_{k-${timeIndex1}} ${algebraicOp1} ${entity3}_{k-${timeIndex2}}†))`,
                    
                    // Pattern 10: mixed operators
                    `${entity1}_t ${modalOp}${algebraicOp1}(${entity2}_{k-${timeIndex1}} ∘ (${entity3}_{k-${timeIndex2}}†))`
                ];
                
                const pattern = patterns[Math.floor(Math.random() * patterns.length)];
                premises.push(pattern);
            }

            return premises;
        }

        function generateAdvancedPremises() {
            const entities = [];
            while (entities.length < premisesCount + 2) {
                const entity = ADVANCED_ENTITY_NAMES[Math.floor(Math.random() * ADVANCED_ENTITY_NAMES.length)];
                if (!entities.includes(entity)) {
                    entities.push(entity);
                }
            }

            const advancedRelationshipTypes = [
                // Generator patterns
                'is the inverse-{num} generator of {dir}',
                'is a generator node for {entity}, using G₄ inverted on the {axis}-axis',
                'generates {num} via an upward projection and {dir} fusion',
                
                // Mapping patterns 
                'recursively maps {entity} to G₄ via {axis}⁻¹ with axis reversal',
                'is mirror-mapped and one node {variant} of',
                'inverts {num}\'s generator under axis {dir}',
                
                // Complex spatial patterns
                'is one meta-level above and {num} logic gates {dir} of',
                'is above {entity}, G₄ by {axis} gates'
            ];

            const directions = ['North', 'South', 'East', 'West'];
            const axes = ['X', 'Y', 'Z'];
            const numbers = ['one', 'two', 'three'];
            const variants = ['G₁', 'G₂', 'G₃', 'G₄', 'G₅', 'X', 'two'];

            const premises = [];
            for (let i = 0; i < premisesCount; i++) {
                const entity1 = entities[i];
                const entity2 = entities[i + 1];
                let template = advancedRelationshipTypes[Math.floor(Math.random() * advancedRelationshipTypes.length)];
                
                // Replace placeholders with random values
                template = template.replace('{dir}', directions[Math.floor(Math.random() * directions.length)]);
                template = template.replace('{axis}', axes[Math.floor(Math.random() * axes.length)]);
                template = template.replace('{num}', numbers[Math.floor(Math.random() * numbers.length)]);
                template = template.replace('{variant}', variants[Math.floor(Math.random() * variants.length)]);
                template = template.replace('G₄', `G${Math.floor(Math.random() * 5) + 1}`);
                
                // Handle entity replacement in templates
                if (template.includes('{entity}')) {
                    const otherEntity = entities[Math.floor(Math.random() * entities.length)];
                    template = template.replace('{entity}', otherEntity);
                }

                premises.push(`${entity1} ${template} ${entity2}`);
            }

            return premises;
        }

        function checkPremisesCompatibility(premises1, premises2) {
            if (selectedMode === 'ultra') {
                return evaluateUltraSemanticEquivalence(premises1, premises2);
            } else if (selectedMode === 'advanced') {
                return evaluateAdvancedComputationalEquivalence(premises1, premises2);
            } else {
                return evaluateRelationalSemanticEquivalence(premises1, premises2);
            }
        }

        // ═══════════════ ULTRA-N-RELATIONAL-REASONING (REDESIGNED) ═══════════════
        // Focus on logical equivalence through canonical form reduction and semantic evaluation
        function evaluateUltraSemanticEquivalence(premises1, premises2) {
            try {
                console.log('\n=== ULTRA SEMANTIC EQUIVALENCE EVALUATION ===');
                console.log('Statements 1:', premises1);
                console.log('Statements 2:', premises2);
                
                // Convert expressions to canonical forms for comparison
                const canonical1 = premises1.map(convertToCanonicalForm);
                const canonical2 = premises2.map(convertToCanonicalForm);
                
                console.log('Canonical forms 1:', canonical1);
                console.log('Canonical forms 2:', canonical2);
                
                // Check for logical equivalence using multiple criteria
                const semanticEquivalence = checkSemanticEquivalence(canonical1, canonical2);
                console.log('Semantic equivalence result:', semanticEquivalence);
                
                return semanticEquivalence;
                
            } catch (error) {
                console.log('Error in ultra semantic evaluation:', error);
                return false;
            }
        }
        
        function convertToCanonicalForm(premise) {
            // Parse and normalize the expression to canonical form
            const parsed = parseUltraExpressionToAST(premise);
            const normalized = normalizeAST(parsed);
            const canonical = {
                originalExpression: premise,
                normalizedAST: normalized,
                modalContext: extractModalContext(parsed),
                temporalSignature: extractTemporalSignature(parsed),
                algebraicSignature: extractAlgebraicSignature(parsed),
                entityMapping: extractEntityMapping(parsed),
                logicalStructure: analyzeLogicalStructure(parsed)
            };
            
            return canonical;
        }
        
        function parseUltraExpressionToAST(premise) {
            // Build a complete Abstract Syntax Tree for the expression
            const tokens = tokenizeUltraExpression(premise);
            const ast = buildAST(tokens);
            return ast;
        }
        
        function tokenizeUltraExpression(premise) {
            // Enhanced tokenization that captures all elements
            const tokens = [];
            const patterns = [
                { type: 'ENTITY_CURRENT', regex: /([α-ωA-M])_t/g },
                { type: 'ENTITY_PAST', regex: /([α-ωA-M])_{k-(\d+)}/g },
                { type: 'ENTITY_INVERSE', regex: /([α-ωA-M])_{(?:t|k-\d+)}†/g },
                { type: 'MODAL_OP', regex: /[□◇◻◉]/g },
                { type: 'ALGEBRAIC_OP', regex: /[⊗⋄◦∘⊕⊖≺≻]/g },
                { type: 'PAREN_OPEN', regex: /\(/g },
                { type: 'PAREN_CLOSE', regex: /\)/g }
            ];
            
            // Create a position-sorted list of all tokens
            const allMatches = [];
            patterns.forEach(pattern => {
                let match;
                while ((match = pattern.regex.exec(premise)) !== null) {
                    allMatches.push({
                        type: pattern.type,
                        value: match[0],
                        position: match.index,
                        groups: match.slice(1)
                    });
                }
            });
            
            // Sort by position and return
            return allMatches.sort((a, b) => a.position - b.position);
        }
        
        function buildAST(tokens) {
            // Build Abstract Syntax Tree using recursive descent parsing
            let position = 0;
            
            function parseExpression() {
                return parseModalExpression();
            }
            
            function parseModalExpression() {
                let expr = parseAlgebraicExpression();
                
                while (position < tokens.length && tokens[position].type === 'MODAL_OP') {
                    const modalOp = tokens[position++];
                    const right = parseAlgebraicExpression();
                    expr = {
                        type: 'MODAL_OPERATION',
                        operator: modalOp.value,
                        operand: right,
                        subject: expr
                    };
                }
                
                return expr;
            }
            
            function parseAlgebraicExpression() {
                let expr = parsePrimary();
                
                while (position < tokens.length && tokens[position].type === 'ALGEBRAIC_OP') {
                    const operator = tokens[position++];
                    const right = parsePrimary();
                    expr = {
                        type: 'ALGEBRAIC_OPERATION',
                        operator: operator.value,
                        left: expr,
                        right: right
                    };
                }
                
                return expr;
            }
            
            function parsePrimary() {
                if (position >= tokens.length) return null;
                
                const token = tokens[position];
                
                if (token.type.startsWith('ENTITY')) {
                    position++;
                    return {
                        type: 'ENTITY',
                        symbol: token.groups[0] || token.value.match(/[α-ωA-M]/)[0],
                        temporal: extractTemporalInfo(token.value),
                        isInverse: token.value.includes('†')
                    };
                } else if (token.type === 'PAREN_OPEN') {
                    position++; // Skip '('
                    const expr = parseExpression();
                    position++; // Skip ')'
                    return {
                        type: 'GROUPED_EXPRESSION',
                        expression: expr
                    };
                }
                
                return null;
            }
            
            function extractTemporalInfo(entityStr) {
                if (entityStr.includes('_t')) return { type: 'current', offset: 0 };
                const match = entityStr.match(/k-(\d+)/);
                return match ? { type: 'past', offset: -parseInt(match[1]) } : { type: 'current', offset: 0 };
            }
            
            return parseExpression();
        }
        
        function normalizeAST(ast) {
            // Normalize the AST by applying algebraic equivalences
            if (!ast) return null;
            
            switch (ast.type) {
                case 'ALGEBRAIC_OPERATION':
                    // Apply commutativity for commutative operators
                    if (isCommutative(ast.operator)) {
                        const left = normalizeAST(ast.left);
                        const right = normalizeAST(ast.right);
                        
                        // Canonicalize order (smaller entity first)
                        if (compareEntities(left, right) > 0) {
                            return {
                                ...ast,
                                left: right,
                                right: left
                            };
                        }
                        return {
                            ...ast,
                            left: left,
                            right: right
                        };
                    }
                    return {
                        ...ast,
                        left: normalizeAST(ast.left),
                        right: normalizeAST(ast.right)
                    };
                    
                case 'MODAL_OPERATION':
                    return {
                        ...ast,
                        subject: normalizeAST(ast.subject),
                        operand: normalizeAST(ast.operand)
                    };
                    
                case 'GROUPED_EXPRESSION':
                    return normalizeAST(ast.expression);
                    
                default:
                    return ast;
            }
        }
        
        function isCommutative(operator) {
            return ['⊕', '⊖', '⊗', '⋄'].includes(operator);
        }
        
        function compareEntities(entity1, entity2) {
            if (!entity1 || !entity2) return 0;
            if (entity1.type !== 'ENTITY' || entity2.type !== 'ENTITY') return 0;
            
            // Compare by symbol first, then by temporal offset
            if (entity1.symbol < entity2.symbol) return -1;
            if (entity1.symbol > entity2.symbol) return 1;
            return entity1.temporal.offset - entity2.temporal.offset;
        }
        
        function extractModalContext(ast) {
            const modalOps = [];
            
            function traverse(node) {
                if (!node) return;
                if (node.type === 'MODAL_OPERATION') {
                    modalOps.push(node.operator);
                }
                if (node.subject) traverse(node.subject);
                if (node.operand) traverse(node.operand);
                if (node.left) traverse(node.left);
                if (node.right) traverse(node.right);
                if (node.expression) traverse(node.expression);
            }
            
            traverse(ast);
            return modalOps;
        }
        
        function extractTemporalSignature(ast) {
            const signature = new Map();
            
            function traverse(node) {
                if (!node) return;
                if (node.type === 'ENTITY') {
                    const key = `${node.symbol}_${node.temporal.type}${node.temporal.offset}`;
                    signature.set(key, (signature.get(key) || 0) + 1);
                }
                if (node.subject) traverse(node.subject);
                if (node.operand) traverse(node.operand);
                if (node.left) traverse(node.left);
                if (node.right) traverse(node.right);
                if (node.expression) traverse(node.expression);
            }
            
            traverse(ast);
            return signature;
        }
        
        function extractAlgebraicSignature(ast) {
            const signature = new Map();
            
            function traverse(node) {
                if (!node) return;
                if (node.type === 'ALGEBRAIC_OPERATION') {
                    signature.set(node.operator, (signature.get(node.operator) || 0) + 1);
                }
                if (node.subject) traverse(node.subject);
                if (node.operand) traverse(node.operand);
                if (node.left) traverse(node.left);
                if (node.right) traverse(node.right);
                if (node.expression) traverse(node.expression);
            }
            
            traverse(ast);
            return signature;
        }
        
        function extractEntityMapping(ast) {
            const entities = new Map();
            
            function traverse(node) {
                if (!node) return;
                if (node.type === 'ENTITY') {
                    const key = node.symbol;
                    if (!entities.has(key)) entities.set(key, []);
                    entities.get(key).push({
                        temporal: node.temporal,
                        isInverse: node.isInverse
                    });
                }
                if (node.subject) traverse(node.subject);
                if (node.operand) traverse(node.operand);
                if (node.left) traverse(node.left);
                if (node.right) traverse(node.right);
                if (node.expression) traverse(node.expression);
            }
            
            traverse(ast);
            return entities;
        }
        
        function analyzeLogicalStructure(ast) {
            return {
                depth: calculateASTDepth(ast),
                complexity: calculateComplexityScore(ast),
                modalDepth: calculateModalDepth(ast),
                algebraicDepth: calculateAlgebraicDepth(ast)
            };
        }
        
        function calculateASTDepth(ast) {
            if (!ast) return 0;
            
            const depths = [
                ast.subject ? calculateASTDepth(ast.subject) : 0,
                ast.operand ? calculateASTDepth(ast.operand) : 0,
                ast.left ? calculateASTDepth(ast.left) : 0,
                ast.right ? calculateASTDepth(ast.right) : 0,
                ast.expression ? calculateASTDepth(ast.expression) : 0
            ];
            
            return 1 + Math.max(...depths);
        }
        
        function calculateComplexityScore(ast) {
            if (!ast) return 0;
            
            const weights = {
                'ENTITY': 1,
                'MODAL_OPERATION': 3,
                'ALGEBRAIC_OPERATION': 2,
                'GROUPED_EXPRESSION': 1
            };
            
            let score = weights[ast.type] || 0;
            
            if (ast.subject) score += calculateComplexityScore(ast.subject);
            if (ast.operand) score += calculateComplexityScore(ast.operand);
            if (ast.left) score += calculateComplexityScore(ast.left);
            if (ast.right) score += calculateComplexityScore(ast.right);
            if (ast.expression) score += calculateComplexityScore(ast.expression);
            
            return score;
        }
        
        function calculateModalDepth(ast) {
            if (!ast) return 0;
            
            let depth = ast.type === 'MODAL_OPERATION' ? 1 : 0;
            
            const childDepths = [
                ast.subject ? calculateModalDepth(ast.subject) : 0,
                ast.operand ? calculateModalDepth(ast.operand) : 0,
                ast.left ? calculateModalDepth(ast.left) : 0,
                ast.right ? calculateModalDepth(ast.right) : 0,
                ast.expression ? calculateModalDepth(ast.expression) : 0
            ];
            
            return depth + Math.max(...childDepths);
        }
        
        function calculateAlgebraicDepth(ast) {
            if (!ast) return 0;
            
            let depth = ast.type === 'ALGEBRAIC_OPERATION' ? 1 : 0;
            
            const childDepths = [
                ast.subject ? calculateAlgebraicDepth(ast.subject) : 0,
                ast.operand ? calculateAlgebraicDepth(ast.operand) : 0,
                ast.left ? calculateAlgebraicDepth(ast.left) : 0,
                ast.right ? calculateAlgebraicDepth(ast.right) : 0,
                ast.expression ? calculateAlgebraicDepth(ast.expression) : 0
            ];
            
            return depth + Math.max(...childDepths);
        }
        
        function checkSemanticEquivalence(canonical1, canonical2) {
            // Multi-dimensional equivalence checking
            
            // 1. Modal equivalence (must have compatible modal contexts)
            const modalEquivalence = checkModalEquivalence(canonical1, canonical2);
            console.log('Modal equivalence:', modalEquivalence);
            
            // 2. Structural equivalence (similar logical structure)
            const structuralEquivalence = checkStructuralEquivalence(canonical1, canonical2);
            console.log('Structural equivalence:', structuralEquivalence);
            
            // 3. Entity-temporal equivalence (shared entities with consistent temporal relationships)
            const entityTemporalEquivalence = checkEntityTemporalEquivalence(canonical1, canonical2);
            console.log('Entity-temporal equivalence:', entityTemporalEquivalence);
            
            // 4. Algebraic equivalence (equivalent algebraic operations)
            const algebraicEquivalence = checkAlgebraicEquivalence(canonical1, canonical2);
            console.log('Algebraic equivalence:', algebraicEquivalence);
            
            // Weighted combination - all aspects must be satisfied for Ultra mode
            const overallEquivalence = modalEquivalence && structuralEquivalence && 
                                     entityTemporalEquivalence && algebraicEquivalence;
            
            return overallEquivalence;
        }
        
        function checkModalEquivalence(canonical1, canonical2) {
            // Extract modal contexts from both sets
            const modals1 = canonical1.flatMap(c => c.modalContext);
            const modals2 = canonical2.flatMap(c => c.modalContext);
            
            // For equivalence, modal operators must be compatible
            const modalCompatibility = {
                '□': ['□', '◻'], // Necessity compatible with necessity variants
                '◇': ['◇', '◉'], // Possibility compatible with contingency
                '◻': ['◻', '□'], // Dual necessity compatible with necessity
                '◉': ['◉', '◇']  // Contingency compatible with possibility
            };
            
            // Check if all modals in set 1 are compatible with modals in set 2
            for (const modal1 of modals1) {
                const compatible = modals2.some(modal2 => 
                    modalCompatibility[modal1]?.includes(modal2) || modal1 === modal2
                );
                if (!compatible && modals2.length > 0) {
                    return false;
                }
            }
            
            return true;
        }
        
        function checkStructuralEquivalence(canonical1, canonical2) {
            // Compare logical structures
            const struct1 = canonical1.map(c => c.logicalStructure);
            const struct2 = canonical2.map(c => c.logicalStructure);
            
            // Calculate average complexity scores
            const avgComplexity1 = struct1.reduce((sum, s) => sum + s.complexity, 0) / struct1.length;
            const avgComplexity2 = struct2.reduce((sum, s) => sum + s.complexity, 0) / struct2.length;
            
            // Calculate average depths
            const avgDepth1 = struct1.reduce((sum, s) => sum + s.depth, 0) / struct1.length;
            const avgDepth2 = struct2.reduce((sum, s) => sum + s.depth, 0) / struct2.length;
            
            // Check if structures are within reasonable similarity bounds
            const complexitySimilarity = Math.abs(avgComplexity1 - avgComplexity2) <= 2;
            const depthSimilarity = Math.abs(avgDepth1 - avgDepth2) <= 1;
            
            return complexitySimilarity && depthSimilarity;
        }
        
        function checkEntityTemporalEquivalence(canonical1, canonical2) {
            // Find shared entities across both sets
            const entities1 = new Set();
            const entities2 = new Set();
            
            canonical1.forEach(c => {
                c.entityMapping.forEach((_, entity) => entities1.add(entity));
            });
            
            canonical2.forEach(c => {
                c.entityMapping.forEach((_, entity) => entities2.add(entity));
            });
            
            const sharedEntities = [...entities1].filter(e => entities2.has(e));
            
            if (sharedEntities.length === 0) {
                return false; // No shared entities means no temporal relationship
            }
            
            // For shared entities, check temporal consistency
            for (const entity of sharedEntities) {
                let temporalMap1 = new Map();
                let temporalMap2 = new Map();
                
                canonical1.forEach(c => {
                    if (c.entityMapping.has(entity)) {
                        c.entityMapping.get(entity).forEach(occurrence => {
                            const key = `${occurrence.temporal.type}_${occurrence.temporal.offset}`;
                            temporalMap1.set(key, true);
                        });
                    }
                });
                
                canonical2.forEach(c => {
                    if (c.entityMapping.has(entity)) {
                        c.entityMapping.get(entity).forEach(occurrence => {
                            const key = `${occurrence.temporal.type}_${occurrence.temporal.offset}`;
                            temporalMap2.set(key, true);
                        });
                    }
                });
                
                // Check if there's any temporal overlap
                const hasOverlap = [...temporalMap1.keys()].some(key => temporalMap2.has(key));
                if (!hasOverlap) {
                    return false;
                }
            }
            
            return true;
        }
        
        function checkAlgebraicEquivalence(canonical1, canonical2) {
            // Extract algebraic signatures
            const algebras1 = canonical1.map(c => c.algebraicSignature);
            const algebras2 = canonical2.map(c => c.algebraicSignature);
            
            // Combine all algebraic operations
            const combinedAlgebra1 = new Map();
            const combinedAlgebra2 = new Map();
            
            algebras1.forEach(alg => {
                alg.forEach((count, op) => {
                    combinedAlgebra1.set(op, (combinedAlgebra1.get(op) || 0) + count);
                });
            });
            
            algebras2.forEach(alg => {
                alg.forEach((count, op) => {
                    combinedAlgebra2.set(op, (combinedAlgebra2.get(op) || 0) + count);
                });
            });
            
            // Check for algebraic equivalence classes
            const equivalenceClasses = {
                'composition': ['◦', '∘'],
                'vector_ops': ['⊕', '⊖'],
                'precedence': ['≺', '≻'],
                'advanced': ['⊗', '⋄']
            };
            
            // Convert to equivalence class counts
            const classes1 = new Map();
            const classes2 = new Map();
            
            Object.entries(equivalenceClasses).forEach(([className, ops]) => {
                const count1 = ops.reduce((sum, op) => sum + (combinedAlgebra1.get(op) || 0), 0);
                const count2 = ops.reduce((sum, op) => sum + (combinedAlgebra2.get(op) || 0), 0);
                if (count1 > 0) classes1.set(className, count1);
                if (count2 > 0) classes2.set(className, count2);
            });
            
            // Check if both sets use similar algebraic operation classes
            const sharedClasses = [...classes1.keys()].filter(cls => classes2.has(cls));
            
            return sharedClasses.length > 0;
        }

        // ═══════════════ ADVANCED-N-RELATIONAL-REASONING ═══════════════
        // Sophisticated computational graph simulation and equivalence checking
        function evaluateAdvancedComputationalEquivalence(premises1, premises2) {
            try {
                console.log('\n=== ADVANCED COMPUTATIONAL EVALUATION ===');
                
                // Build computational models for both premise sets
                const compModel1 = buildComputationalModel(premises1);
                const compModel2 = buildComputationalModel(premises2);
                
                console.log('Computational Model 1:', compModel1);
                console.log('Computational Model 2:', compModel2);
                
                // Find shared computational entities
                const sharedNodes = findSharedComputationalNodes(compModel1, compModel2);
                if (sharedNodes.length === 0) {
                    console.log('No shared computational nodes - INCOMPATIBLE');
                    return false;
                }
                
                // Simulate computational processes
                const simulation1 = simulateComputationalGraph(compModel1);
                const simulation2 = simulateComputationalGraph(compModel2);
                
                console.log('Simulation 1 result:', simulation1);
                console.log('Simulation 2 result:', simulation2);
                
                // Check computational equivalence
                const computationalEquivalence = checkComputationalEquivalence(simulation1, simulation2, sharedNodes);
                console.log('Computational equivalence:', computationalEquivalence);
                
                // Verify generator consistency
                const generatorConsistency = verifyGeneratorConsistency(compModel1, compModel2, sharedNodes);
                console.log('Generator consistency:', generatorConsistency);
                
                // Check mapping compatibility
                const mappingCompatibility = checkMappingCompatibility(compModel1, compModel2, sharedNodes);
                console.log('Mapping compatibility:', mappingCompatibility);
                
                const result = computationalEquivalence && generatorConsistency && mappingCompatibility;
                console.log('ADVANCED LOGIC RESULT:', result ? 'COMPATIBLE' : 'INCOMPATIBLE');
                return result;
                
            } catch (error) {
                console.log('Error in advanced computational evaluation:', error);
                return false;
            }
        }
        
        function buildComputationalModel(premises) {
            const model = {
                entities: new Map(),      // entity -> computational node
                generators: new Map(),    // entity -> generator definition
                mappings: new Map(),      // entity -> mapping operations
                spatialOps: new Map(),    // entity -> spatial operations
                dependencies: new Map(),  // entity -> dependencies
                computationGraph: new Map() // complete computational graph
            };
            
            premises.forEach((premise, idx) => {
                const parsed = parseAdvancedComputationalStatement(premise);
                
                // Create computational nodes
                const subjectNode = {
                    id: parsed.subject,
                    type: 'entity',
                    operations: [],
                    state: new Map(),
                    connections: []
                };
                
                const objectNode = {
                    id: parsed.object,
                    type: 'entity',
                    operations: [],
                    state: new Map(),
                    connections: []
                };
                
                model.entities.set(parsed.subject, subjectNode);
                model.entities.set(parsed.object, objectNode);
                
                // Process relationship type
                if (parsed.relationType === 'generator') {
                    const generatorDef = {
                        sourceEntity: parsed.object,
                        targetEntity: parsed.subject,
                        generatorType: parsed.parameters.generator,
                        isInverse: parsed.parameters.isInverse,
                        direction: parsed.parameters.direction,
                        operation: createGeneratorOperation(parsed.parameters)
                    };
                    
                    model.generators.set(`${parsed.subject}-${parsed.object}`, generatorDef);
                    
                    // Add to computation graph
                    if (!model.computationGraph.has(parsed.object)) {
                        model.computationGraph.set(parsed.object, []);
                    }
                    model.computationGraph.get(parsed.object).push({
                        target: parsed.subject,
                        operation: 'generate',
                        parameters: generatorDef
                    });
                    
                } else if (parsed.relationType === 'mapping') {
                    const mappingDef = {
                        sourceEntity: parsed.subject,
                        targetEntity: parsed.object,
                        mappingType: parsed.parameters.isMirror ? 'mirror' : 'direct',
                        isRecursive: parsed.parameters.isRecursive,
                        axis: parsed.parameters.axis,
                        operation: createMappingOperation(parsed.parameters)
                    };
                    
                    model.mappings.set(`${parsed.subject}-${parsed.object}`, mappingDef);
                    
                    // Add to computation graph
                    if (!model.computationGraph.has(parsed.subject)) {
                        model.computationGraph.set(parsed.subject, []);
                    }
                    model.computationGraph.get(parsed.subject).push({
                        target: parsed.object,
                        operation: 'map',
                        parameters: mappingDef
                    });
                    
                } else if (parsed.relationType === 'spatial') {
                    const spatialDef = {
                        sourceEntity: parsed.object,
                        targetEntity: parsed.subject,
                        level: parsed.parameters.level,
                        direction: parsed.parameters.direction,
                        gateCount: parsed.parameters.gateCount,
                        operation: createSpatialOperation(parsed.parameters)
                    };
                    
                    model.spatialOps.set(`${parsed.subject}-${parsed.object}`, spatialDef);
                    
                    // Add to computation graph
                    if (!model.computationGraph.has(parsed.object)) {
                        model.computationGraph.set(parsed.object, []);
                    }
                    model.computationGraph.get(parsed.object).push({
                        target: parsed.subject,
                        operation: 'spatial_transform',
                        parameters: spatialDef
                    });
                }
                
                // Build dependency graph
                if (!model.dependencies.has(parsed.subject)) {
                    model.dependencies.set(parsed.subject, []);
                }
                model.dependencies.get(parsed.subject).push(parsed.object);
            });
            
            return model;
        }
        
        function parseAdvancedComputationalStatement(premise) {
            // Enhanced parsing for computational statements
            const match = premise.match(/(\w+)\s+(.*?)\s+(\w+)$/);
            if (!match) return null;

            const [, subject, relationText, object] = match;
            const structure = {
                subject,
                object,
                relationType: null,
                parameters: {},
                originalText: premise
            };

            // Detailed relationship classification
            if (relationText.includes('generator')) {
                structure.relationType = 'generator';
                structure.parameters.isInverse = relationText.includes('inverse');
                structure.parameters.direction = extractDirectionAdvanced(relationText);
                structure.parameters.generator = extractGeneratorType(relationText);
                structure.parameters.projection = relationText.includes('projection');
                structure.parameters.fusion = relationText.includes('fusion');
            } else if (relationText.includes('maps') || relationText.includes('mapped')) {
                structure.relationType = 'mapping';
                structure.parameters.isMirror = relationText.includes('mirror');
                structure.parameters.isRecursive = relationText.includes('recursive');
                structure.parameters.axis = extractAxisAdvanced(relationText);
                structure.parameters.hasAxisReversal = relationText.includes('axis reversal');
                structure.parameters.inverts = relationText.includes('inverts');
            } else if (relationText.includes('meta-level') || relationText.includes('gates')) {
                structure.relationType = 'spatial';
                structure.parameters.level = extractLevelAdvanced(relationText);
                structure.parameters.direction = extractDirectionAdvanced(relationText);
                structure.parameters.gateCount = extractGateCountAdvanced(relationText);
                structure.parameters.isAbove = relationText.includes('above');
            }

            return structure;
        }
        
        function extractDirectionAdvanced(text) {
            const directions = ['North', 'South', 'East', 'West', 'upward', 'downward'];
            for (const dir of directions) {
                if (text.includes(dir)) return dir;
            }
            return null;
        }
        
        function extractGeneratorType(text) {
            const match = text.match(/G[₁₂₃₄₅]/);
            if (match) return match[0];
            
            // Check for G followed by number
            const numMatch = text.match(/G(\d)/);
            return numMatch ? `G${numMatch[1]}` : 'G1';
        }
        
        function extractAxisAdvanced(text) {
            const axes = ['X', 'Y', 'Z'];
            for (const axis of axes) {
                if (text.includes(axis)) {
                    // Check for inverse notation
                    if (text.includes(axis + '⁻¹')) {
                        return { axis: axis, isInverse: true };
                    }
                    return { axis: axis, isInverse: false };
                }
            }
            return null;
        }
        
        function extractLevelAdvanced(text) {
            if (text.includes('meta-level')) return 'meta';
            if (text.includes('base-level')) return 'base';
            return 'standard';
        }
        
        function extractGateCountAdvanced(text) {
            const match = text.match(/(\w+)\s+logic\s+gates/);
            if (match) {
                const word = match[1].toLowerCase();
                const numbers = { 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5 };
                return numbers[word] || 1;
            }
            return 1;
        }
        
        function createGeneratorOperation(parameters) {
            return {
                type: 'generator',
                generator: parameters.generator,
                inverse: parameters.isInverse,
                direction: parameters.direction,
                execute: function(input) {
                    // Simulate generator operation
                    let result = { ...input };
                    
                    // Apply generator transformation based on type
                    const genValue = parseInt(parameters.generator.slice(1)) || 1;
                    result.value = (result.value || 0) * genValue;
                    
                    if (parameters.isInverse) {
                        result.value = -result.value;
                    }
                    
                    if (parameters.direction) {
                        result.direction = parameters.direction;
                    }
                    
                    result.generatedBy = parameters.generator;
                    return result;
                }
            };
        }
        
        function createMappingOperation(parameters) {
            return {
                type: 'mapping',
                mirror: parameters.isMirror,
                recursive: parameters.isRecursive,
                axis: parameters.axis,
                execute: function(input) {
                    // Simulate mapping operation
                    let result = { ...input };
                    
                    if (parameters.isMirror) {
                        result.value = -(result.value || 0);
                    }
                    
                    if (parameters.axis && parameters.axis.axis) {
                        result.axis = parameters.axis.axis;
                        if (parameters.axis.isInverse) {
                            result.value = 1 / (result.value || 1);
                        }
                    }
                    
                    if (parameters.isRecursive) {
                        result.recursive = true;
                        result.depth = (result.depth || 0) + 1;
                    }
                    
                    result.mappedBy = 'mapping';
                    return result;
                }
            };
        }
        
        function createSpatialOperation(parameters) {
            return {
                type: 'spatial',
                level: parameters.level,
                direction: parameters.direction,
                gates: parameters.gateCount,
                execute: function(input) {
                    // Simulate spatial transformation
                    let result = { ...input };
                    
                    if (parameters.level === 'meta') {
                        result.level = (result.level || 0) + 1;
                    }
                    
                    if (parameters.direction) {
                        result.direction = parameters.direction;
                    }
                    
                    if (parameters.gateCount) {
                        result.gates = parameters.gateCount;
                        result.value = (result.value || 0) + parameters.gateCount;
                    }
                    
                    result.spatialTransform = true;
                    return result;
                }
            };
        }
        
        function findSharedComputationalNodes(model1, model2) {
            const shared = [];
            
            for (const [entityId, node1] of model1.entities) {
                if (model2.entities.has(entityId)) {
                    const node2 = model2.entities.get(entityId);
                    shared.push({
                        entity: entityId,
                        node1: node1,
                        node2: node2
                    });
                }
            }
            
            return shared;
        }
        
        function simulateComputationalGraph(model) {
            const results = new Map();
            const computationOrder = topologicalSort(model.computationGraph);
            
            // Initialize all entities with base state
            for (const entityId of model.entities.keys()) {
                results.set(entityId, { value: 1, state: 'initial' });
            }
            
            // Execute computations in topological order
            for (const entityId of computationOrder) {
                if (model.computationGraph.has(entityId)) {
                    const operations = model.computationGraph.get(entityId);
                    const currentState = results.get(entityId);
                    
                    for (const operation of operations) {
                        const targetState = operation.parameters.operation.execute(currentState);
                        results.set(operation.target, targetState);
                    }
                }
            }
            
            return results;
        }
        
        function topologicalSort(graph) {
            const visited = new Set();
            const result = [];
            
            function visit(node) {
                if (visited.has(node)) return;
                visited.add(node);
                
                if (graph.has(node)) {
                    for (const edge of graph.get(node)) {
                        visit(edge.target);
                    }
                }
                
                result.unshift(node);
            }
            
            for (const node of graph.keys()) {
                visit(node);
            }
            
            return result;
        }
        
        function checkComputationalEquivalence(simulation1, simulation2, sharedNodes) {
            for (const shared of sharedNodes) {
                const state1 = simulation1.get(shared.entity);
                const state2 = simulation2.get(shared.entity);
                
                if (!state1 || !state2) continue;
                
                // Check value equivalence with tolerance
                const valueDiff = Math.abs((state1.value || 0) - (state2.value || 0));
                if (valueDiff > 0.1) {
                    console.log(`Value mismatch for ${shared.entity}: ${state1.value} vs ${state2.value}`);
                    return false;
                }
                
                // Check state properties
                if (!compareStateProperties(state1, state2)) {
                    console.log(`State property mismatch for ${shared.entity}`);
                    return false;
                }
            }
            
            return true;
        }
        
        function compareStateProperties(state1, state2) {
            // Compare important state properties
            const important = ['direction', 'axis', 'level', 'generatedBy', 'mappedBy'];
            
            for (const prop of important) {
                if (state1[prop] !== state2[prop]) {
                    // Allow some flexibility for similar values
                    if (prop === 'direction' && areDirectionsSimilar(state1[prop], state2[prop])) {
                        continue;
                    }
                    return false;
                }
            }
            
            return true;
        }
        
        function areDirectionsSimilar(dir1, dir2) {
            const opposites = {
                'North': 'South', 'South': 'North',
                'East': 'West', 'West': 'East',
                'upward': 'downward', 'downward': 'upward'
            };
            
            return dir1 === dir2 || opposites[dir1] === dir2;
        }
        
        function verifyGeneratorConsistency(model1, model2, sharedNodes) {
            // Check if generator operations are consistent
            for (const shared of sharedNodes) {
                const gens1 = findGeneratorsForEntity(model1, shared.entity);
                const gens2 = findGeneratorsForEntity(model2, shared.entity);
                
                if (gens1.length > 0 && gens2.length > 0) {
                    if (!areGeneratorsConsistent(gens1, gens2)) {
                        console.log(`Generator inconsistency for ${shared.entity}`);
                        return false;
                    }
                }
            }
            
            return true;
        }
        
        function findGeneratorsForEntity(model, entityId) {
            const generators = [];
            
            for (const [key, generator] of model.generators) {
                if (generator.targetEntity === entityId || generator.sourceEntity === entityId) {
                    generators.push(generator);
                }
            }
            
            return generators;
        }
        
        function areGeneratorsConsistent(gens1, gens2) {
            // Check for overlapping generators with same type
            for (const gen1 of gens1) {
                for (const gen2 of gens2) {
                    if (gen1.generatorType === gen2.generatorType) {
                        // Same generator type should have consistent properties
                        if (gen1.isInverse !== gen2.isInverse) {
                            return false;
                        }
                        
                        if (gen1.direction && gen2.direction && gen1.direction !== gen2.direction) {
                            // Allow opposite directions (they can be equivalent)
                            if (!areDirectionsSimilar(gen1.direction, gen2.direction)) {
                                return false;
                            }
                        }
                    }
                }
            }
            
            return true;
        }
        
        function checkMappingCompatibility(model1, model2, sharedNodes) {
            // Check if mapping operations are compatible
            for (const shared of sharedNodes) {
                const maps1 = findMappingsForEntity(model1, shared.entity);
                const maps2 = findMappingsForEntity(model2, shared.entity);
                
                if (maps1.length > 0 && maps2.length > 0) {
                    if (!areMappingsCompatible(maps1, maps2)) {
                        console.log(`Mapping incompatibility for ${shared.entity}`);
                        return false;
                    }
                }
            }
            
            return true;
        }
        
        function findMappingsForEntity(model, entityId) {
            const mappings = [];
            
            for (const [key, mapping] of model.mappings) {
                if (mapping.targetEntity === entityId || mapping.sourceEntity === entityId) {
                    mappings.push(mapping);
                }
            }
            
            return mappings;
        }
        
        function areMappingsCompatible(maps1, maps2) {
            // Check for conflicting mappings on same axis
            for (const map1 of maps1) {
                for (const map2 of maps2) {
                    if (map1.axis && map2.axis && map1.axis.axis === map2.axis.axis) {
                        // Same axis should have compatible mappings
                        if (map1.mappingType !== map2.mappingType) {
                            // Mirror vs direct on same axis is incompatible
                            return false;
                        }
                        
                        if (map1.axis.isInverse !== map2.axis.isInverse) {
                            // Inverse mismatch on same axis
                            return false;
                        }
                    }
                }
            }
            
            return true;
        }

        // ═══════════════ RELATIONAL N-BACK (ENHANCED) ═══════════════
        function evaluateRelationalSemanticEquivalence(premises1, premises2) {
            return evaluateRelationalLogicalCompatibility(premises1, premises2);
        }
        
        // Sophisticated geometric reasoning and spatial inference engine
        function evaluateRelationalLogicalCompatibility(premises1, premises2) {
            return arePremisesCompatible(premises1, premises2);
        }

        function arePremisesCompatible(premises1, premises2) {
            try {
                console.log('\n=== SOPHISTICATED RELATIONAL COMPATIBILITY CHECK ===');
                console.log('Premise Set 1:', premises1);
                console.log('Premise Set 2:', premises2);
                
                // Use multiple sophisticated matching strategies
                const strategies = [
                    { name: 'Isomorphic Structure', check: checkIsomorphicCompatibility },
                    { name: 'Rotational Equivalence', check: checkRotationalEquivalence },
                    { name: 'Reflectional Equivalence', check: checkReflectionalEquivalence },
                    { name: 'Translational Equivalence', check: checkTranslationalEquivalence },
                    { name: 'Logical Inversion', check: checkLogicalInversion },
                    { name: 'Partial Structure Match', check: checkPartialStructureMatch },
                    { name: 'Spatial Configuration', check: checkSpatialConfigurationMatch }
                ];
                
                // Check each strategy
                for (const strategy of strategies) {
                    console.log(`\nChecking ${strategy.name}...`);
                    const result = strategy.check(premises1, premises2);
                    if (result) {
                        console.log(`✓ Match found via ${strategy.name}`);
                        return true;
                    }
                }
                
                console.log('✗ No compatibility found');
                return false;
                
            } catch (error) {
                console.log('Error in compatibility check:', error);
                return false;
            }
        }
        
        // Strategy 1: Check if structures are isomorphic (same relationships, different entities)
        function checkIsomorphicCompatibility(premises1, premises2) {
            if (premises1.length !== premises2.length) return false;
            
            // Extract relationship structures
            const struct1 = extractRelationalStructure(premises1);
            const struct2 = extractRelationalStructure(premises2);
            
            // Check if we can create a valid entity mapping
            const entityMapping = findIsomorphicMapping(struct1, struct2);
            if (!entityMapping) return false;
            
            // Verify the mapping preserves all relationships
            return verifyIsomorphicMapping(struct1, struct2, entityMapping);
        }
        
        function extractRelationalStructure(premises) {
            const structure = {
                entities: new Set(),
                relations: [],
                graph: new Map()
            };
            
            premises.forEach(premise => {
                const match = premise.match(/(\w+)\s+is\s+(.*?)\s+of\s+(\w+)/);
                if (match) {
                    const [, entity1, relation, entity2] = match;
                    structure.entities.add(entity1);
                    structure.entities.add(entity2);
                    structure.relations.push({
                        from: entity1,
                        to: entity2,
                        type: normalizeRelation(relation)
                    });
                    
                    // Build adjacency graph
                    if (!structure.graph.has(entity1)) {
                        structure.graph.set(entity1, []);
                    }
                    structure.graph.get(entity1).push({
                        to: entity2,
                        relation: relation
                    });
                }
            });
            
            return structure;
        }
        
        function normalizeRelation(relation) {
            // Normalize to core spatial components
            const normalized = {
                vertical: 0,
                horizontal_x: 0,
                horizontal_y: 0,
                type: 'spatial'
            };
            
            if (relation.includes('above')) normalized.vertical = 1;
            else if (relation.includes('below')) normalized.vertical = -1;
            
            if (relation.includes('North')) normalized.horizontal_y = -1;
            else if (relation.includes('South')) normalized.horizontal_y = 1;
            
            if (relation.includes('East')) normalized.horizontal_x = 1;
            else if (relation.includes('West')) normalized.horizontal_x = -1;
            
            // Extract magnitude
            const magnitudeMatch = relation.match(/(one|two|three|four|five)/);
            if (magnitudeMatch) {
                const magnitudes = { one: 1, two: 2, three: 3, four: 4, five: 5 };
                const mag = magnitudes[magnitudeMatch[1]] || 1;
                normalized.vertical *= mag;
                normalized.horizontal_x *= mag;
                normalized.horizontal_y *= mag;
            }
            
            return normalized;
        }
        
        function findIsomorphicMapping(struct1, struct2) {
            if (struct1.entities.size !== struct2.entities.size) return null;
            
            const entities1 = Array.from(struct1.entities);
            const entities2 = Array.from(struct2.entities);
            
            // Try to find a valid mapping using degree sequence heuristic
            const degrees1 = computeDegreeSequence(struct1);
            const degrees2 = computeDegreeSequence(struct2);
            
            // Group entities by degree
            const byDegree1 = groupByDegree(entities1, degrees1);
            const byDegree2 = groupByDegree(entities2, degrees2);
            
            // Check if degree sequences match
            if (!degreesMatch(byDegree1, byDegree2)) return null;
            
            // Try to construct mapping
            const mapping = new Map();
            return tryBuildMapping(byDegree1, byDegree2, mapping, struct1, struct2);
        }
        
        function computeDegreeSequence(structure) {
            const degrees = new Map();
            
            structure.entities.forEach(entity => {
                degrees.set(entity, 0);
            });
            
            structure.relations.forEach(rel => {
                degrees.set(rel.from, (degrees.get(rel.from) || 0) + 1);
                degrees.set(rel.to, (degrees.get(rel.to) || 0) + 1);
            });
            
            return degrees;
        }
        
        function groupByDegree(entities, degrees) {
            const groups = new Map();
            
            entities.forEach(entity => {
                const degree = degrees.get(entity);
                if (!groups.has(degree)) {
                    groups.set(degree, []);
                }
                groups.get(degree).push(entity);
            });
            
            return groups;
        }
        
        function degreesMatch(byDegree1, byDegree2) {
            if (byDegree1.size !== byDegree2.size) return false;
            
            for (const [degree, entities] of byDegree1) {
                if (!byDegree2.has(degree) || byDegree2.get(degree).length !== entities.length) {
                    return false;
                }
            }
            
            return true;
        }
        
        function tryBuildMapping(byDegree1, byDegree2, mapping, struct1, struct2) {
            // Simple greedy approach - can be made more sophisticated
            for (const [degree, entities1] of byDegree1) {
                const entities2 = byDegree2.get(degree);
                
                for (let i = 0; i < entities1.length; i++) {
                    mapping.set(entities1[i], entities2[i]);
                }
            }
            
            return mapping;
        }
        
        function verifyIsomorphicMapping(struct1, struct2, mapping) {
            // Verify that all relationships are preserved under mapping
            for (const rel1 of struct1.relations) {
                const mappedFrom = mapping.get(rel1.from);
                const mappedTo = mapping.get(rel1.to);
                
                // Find corresponding relation in struct2
                const found = struct2.relations.some(rel2 => 
                    rel2.from === mappedFrom && 
                    rel2.to === mappedTo && 
                    relationsEquivalent(rel1.type, rel2.type)
                );
                
                if (!found) return false;
            }
            
            return true;
        }
        
        function relationsEquivalent(rel1, rel2) {
            return rel1.vertical === rel2.vertical &&
                   rel1.horizontal_x === rel2.horizontal_x &&
                   rel1.horizontal_y === rel2.horizontal_y;
        }
        
        // Strategy 2: Check rotational equivalence
        function checkRotationalEquivalence(premises1, premises2) {
            // Check 90, 180, 270 degree rotations
            const rotations = [90, 180, 270];
            
            for (const angle of rotations) {
                const rotated = rotatePremises(premises1, angle);
                if (checkStructuralEquivalence(rotated, premises2)) {
                    return true;
                }
            }
            
            return false;
        }
        
        function rotatePremises(premises, angle) {
            return premises.map(premise => {
                const match = premise.match(/(\w+)\s+is\s+(.*?)\s+of\s+(\w+)/);
                if (!match) return premise;
                
                const [, entity1, relation, entity2] = match;
                const rotatedRelation = rotateRelation(relation, angle);
                
                return `${entity1} is ${rotatedRelation} of ${entity2}`;
            });
        }
        
        function rotateRelation(relation, angle) {
            const rotationMaps = {
                90: { 'North': 'East', 'East': 'South', 'South': 'West', 'West': 'North' },
                180: { 'North': 'South', 'East': 'West', 'South': 'North', 'West': 'East' },
                270: { 'North': 'West', 'East': 'North', 'South': 'East', 'West': 'South' }
            };
            
            const map = rotationMaps[angle];
            if (!map) return relation;
            
            let rotated = relation;
            Object.entries(map).forEach(([from, to]) => {
                rotated = rotated.replace(new RegExp(from, 'g'), `TEMP_${to}`);
            });
            rotated = rotated.replace(/TEMP_/g, '');
            
            return rotated;
        }
        
        function checkStructuralEquivalence(premises1, premises2) {
            // Check if premises have same structure (possibly with different entities)
            return checkIsomorphicCompatibility(premises1, premises2);
        }
        
        // Strategy 3: Check reflectional equivalence
        function checkReflectionalEquivalence(premises1, premises2) {
            const reflectionAxes = ['horizontal', 'vertical', 'diagonal'];
            
            for (const axis of reflectionAxes) {
                const reflected = reflectPremises(premises1, axis);
                if (checkStructuralEquivalence(reflected, premises2)) {
                    return true;
                }
            }
            
            return false;
        }
        
        function reflectPremises(premises, axis) {
            return premises.map(premise => {
                const match = premise.match(/(\w+)\s+is\s+(.*?)\s+of\s+(\w+)/);
                if (!match) return premise;
                
                const [, entity1, relation, entity2] = match;
                const reflectedRelation = reflectRelation(relation, axis);
                
                return `${entity1} is ${reflectedRelation} of ${entity2}`;
            });
        }
        
        function reflectRelation(relation, axis) {
            const reflectionMaps = {
                'horizontal': { 'North': 'South', 'South': 'North' },
                'vertical': { 'East': 'West', 'West': 'East' },
                'diagonal': { 'North': 'East', 'East': 'North', 'South': 'West', 'West': 'South' }
            };
            
            const map = reflectionMaps[axis];
            if (!map) return relation;
            
            let reflected = relation;
            Object.entries(map).forEach(([from, to]) => {
                reflected = reflected.replace(new RegExp(from, 'g'), `TEMP_${to}`);
            });
            reflected = reflected.replace(/TEMP_/g, '');
            
            // Also reflect vertical relations for horizontal axis
            if (axis === 'horizontal') {
                reflected = reflected.replace(/above/g, 'TEMP_below').replace(/below/g, 'TEMP_above');
                reflected = reflected.replace(/TEMP_/g, '');
            }
            
            return reflected;
        }
        
        // Strategy 4: Check translational equivalence
        function checkTranslationalEquivalence(premises1, premises2) {
            // Check if all relationships are preserved with systematic entity substitution
            const struct1 = extractRelationalStructure(premises1);
            const struct2 = extractRelationalStructure(premises2);
            
            // Relations must be identical
            if (struct1.relations.length !== struct2.relations.length) return false;
            
            // Check if relations match exactly (same spatial relationships)
            const relations1 = struct1.relations.map(r => normalizeRelation(r.type));
            const relations2 = struct2.relations.map(r => normalizeRelation(r.type));
            
            // Sort and compare
            const sorted1 = relations1.sort((a, b) => JSON.stringify(a).localeCompare(JSON.stringify(b)));
            const sorted2 = relations2.sort((a, b) => JSON.stringify(a).localeCompare(JSON.stringify(b)));
            
            return JSON.stringify(sorted1) === JSON.stringify(sorted2);
        }
        
        // Strategy 5: Check logical inversion
        function checkLogicalInversion(premises1, premises2) {
            // Check if premises2 contains inverted versions of premises1
            const inverted1 = premises1.map(invertPremise);
            return checkStructuralEquivalence(inverted1, premises2);
        }
        
        function invertPremise(premise) {
            const match = premise.match(/(\w+)\s+is\s+(.*?)\s+of\s+(\w+)/);
            if (!match) return premise;
            
            const [, entity1, relation, entity2] = match;
            const invertedRelation = invertRelationship(relation);
            
            if (invertedRelation) {
                return `${entity2} is ${invertedRelation} of ${entity1}`;
            }
            
            return premise;
        }
        
        // Strategy 6: Check partial structure match (60% threshold)
        function checkPartialStructureMatch(premises1, premises2) {
            if (premises1.length !== premises2.length) return false;
            
            const threshold = 0.6; // 60% match required
            let matches = 0;
            
            // Try to match each premise in set1 with any premise in set2
            const used = new Set();
            
            for (const p1 of premises1) {
                for (let i = 0; i < premises2.length; i++) {
                    if (used.has(i)) continue;
                    
                    if (premisesMatch(p1, premises2[i])) {
                        matches++;
                        used.add(i);
                        break;
                    }
                }
            }
            
            return matches / premises1.length >= threshold;
        }
        
        function premisesMatch(p1, p2) {
            // Check if individual premises match (structure or exact)
            const struct1 = extractPremiseStructure(p1);
            const struct2 = extractPremiseStructure(p2);
            
            // Exact relation match
            if (struct1.relation === struct2.relation) return true;
            
            // Normalized relation match
            const norm1 = normalizeRelation(struct1.relation);
            const norm2 = normalizeRelation(struct2.relation);
            
            return relationsEquivalent(norm1, norm2);
        }
        
        function extractPremiseStructure(premise) {
            const match = premise.match(/(\w+)\s+is\s+(.*?)\s+of\s+(\w+)/);
            if (!match) return null;
            
            return {
                from: match[1],
                relation: match[2],
                to: match[3]
            };
        }
        
        // Strategy 7: Check spatial configuration match
        function checkSpatialConfigurationMatch(premises1, premises2) {
            // Build spatial maps and check if configurations are equivalent
            const config1 = buildSpatialConfiguration(premises1);
            const config2 = buildSpatialConfiguration(premises2);
            
            return configurationsEquivalent(config1, config2);
        }
        
        function buildSpatialConfiguration(premises) {
            const positions = new Map();
            const constraints = [];
            
            // Extract constraints
            premises.forEach(premise => {
                const match = premise.match(/(\w+)\s+is\s+(.*?)\s+of\s+(\w+)/);
                if (match) {
                    const [, entity1, relation, entity2] = match;
                    const spatial = parseRelationToCoordinates(relation);
                    constraints.push({
                        from: entity2,
                        to: entity1,
                        offset: spatial
                    });
                }
            });
            
            // Try to build consistent position map
            if (constraints.length === 0) return positions;
            
            // Place first entity at origin
            const firstConstraint = constraints[0];
            positions.set(firstConstraint.from, { x: 0, y: 0, z: 0 });
            positions.set(firstConstraint.to, firstConstraint.offset);
            
            // Propagate positions
            let changed = true;
            while (changed) {
                changed = false;
                
                for (const constraint of constraints) {
                    if (positions.has(constraint.from) && !positions.has(constraint.to)) {
                        const fromPos = positions.get(constraint.from);
                        positions.set(constraint.to, {
                            x: fromPos.x + constraint.offset.x,
                            y: fromPos.y + constraint.offset.y,
                            z: fromPos.z + constraint.offset.z
                        });
                        changed = true;
                    }
                }
            }
            
            return positions;
        }
        
        function parseRelationToCoordinates(relation) {
            let x = 0, y = 0, z = 0;
            
            // Parse vertical
            if (relation.includes('above')) {
                const match = relation.match(/(one|two|three|four|five)/);
                const nums = { one: 1, two: 2, three: 3, four: 4, five: 5 };
                z = match ? nums[match[1]] : 1;
            } else if (relation.includes('below')) {
                const match = relation.match(/(one|two|three|four|five)/);
                const nums = { one: 1, two: 2, three: 3, four: 4, five: 5 };
                z = match ? -nums[match[1]] : -1;
            }
            
            // Parse horizontal
            if (relation.includes('North')) {
                const match = relation.match(/(one|two|three|four|five)/);
                const nums = { one: 1, two: 2, three: 3, four: 4, five: 5 };
                y = match ? -nums[match[1]] : -1;
            } else if (relation.includes('South')) {
                const match = relation.match(/(one|two|three|four|five)/);
                const nums = { one: 1, two: 2, three: 3, four: 4, five: 5 };
                y = match ? nums[match[1]] : 1;
            }
            
            if (relation.includes('East')) {
                const match = relation.match(/(one|two|three|four|five)/);
                const nums = { one: 1, two: 2, three: 3, four: 4, five: 5 };
                x = match ? nums[match[1]] : 1;
            } else if (relation.includes('West')) {
                const match = relation.match(/(one|two|three|four|five)/);
                const nums = { one: 1, two: 2, three: 3, four: 4, five: 5 };
                x = match ? -nums[match[1]] : -1;
            }
            
            return { x, y, z };
        }
        
        function configurationsEquivalent(config1, config2) {
            if (config1.size !== config2.size) return false;
            
            // Normalize both configurations (translate to common origin)
            const norm1 = normalizeConfiguration(config1);
            const norm2 = normalizeConfiguration(config2);
            
            // Check if normalized configurations match
            return checkNormalizedConfigMatch(norm1, norm2);
        }
        
        function normalizeConfiguration(config) {
            if (config.size === 0) return config;
            
            // Find min coordinates
            let minX = Infinity, minY = Infinity, minZ = Infinity;
            
            for (const pos of config.values()) {
                minX = Math.min(minX, pos.x);
                minY = Math.min(minY, pos.y);
                minZ = Math.min(minZ, pos.z);
            }
            
            // Translate to origin
            const normalized = new Map();
            for (const [entity, pos] of config) {
                normalized.set(entity, {
                    x: pos.x - minX,
                    y: pos.y - minY,
                    z: pos.z - minZ
                });
            }
            
            return normalized;
        }
        
        function checkNormalizedConfigMatch(config1, config2) {
            // Extract position sets (ignoring entity names)
            const positions1 = new Set();
            const positions2 = new Set();
            
            for (const pos of config1.values()) {
                positions1.add(`${pos.x},${pos.y},${pos.z}`);
            }
            
            for (const pos of config2.values()) {
                positions2.add(`${pos.x},${pos.y},${pos.z}`);
            }
            
            // Check if position sets match
            if (positions1.size !== positions2.size) return false;
            
            for (const pos of positions1) {
                if (!positions2.has(pos)) return false;
            }
            
            return true;
        }
        
        function getEntitiesFromConstraints(constraints) {
            const entities = new Set();
            constraints.forEach(c => {
                entities.add(c.from);
                entities.add(c.to);
            });
            return Array.from(entities);
        }
        
        function startNewTrial() {
            if (currentTrial >= maxTrials) {
                endSession();
                return;
            }

            const position = generateRandomPosition();
            const premises = generatePremises();
            
            if (selectedMode === 'spatial' || selectedMode === 'dual') {
                currentPosition = position;
                positionHistory.push(position);
            }
            if (selectedMode === 'relational' || selectedMode === 'dual' || selectedMode === 'advanced' || selectedMode === 'ultra') {
                currentPremises = premises;
                premisesHistory.push(premises);
            }
            
            currentTrial++;
            
            spatialResponseGiven = false;
            relationalResponseGiven = false;
            
            if (currentTrial > nBackLevel) {
                if (selectedMode === 'spatial' || selectedMode === 'dual') {
                    const nBackPosition = positionHistory[currentTrial - nBackLevel - 1];
                    if (nBackPosition !== undefined && nBackPosition === currentPosition) {
                        spatialScore.actualMatches += 1;
                    }
                }
                
                if (selectedMode === 'relational' || selectedMode === 'dual' || selectedMode === 'advanced' || selectedMode === 'ultra') {
                    const nBackPremises = premisesHistory[currentTrial - nBackLevel - 1];
                    if (nBackPremises !== undefined && checkPremisesCompatibility(currentPremises, nBackPremises)) {
                        relationalScore.actualMatches += 1;
                    }
                }
            }
            
            // Update interference strength for spatial mode
            if (selectedMode === 'spatial') {
                updateInterferenceStrength();
                setupInterferenceEffects();
            }
            
            updateDisplay();
            showCurrentTrial();
            
            trialTimeout = setTimeout(() => {
                hideCurrentTrial();
                setTimeout(() => {
                    if (isPlaying) {
                        startNewTrial();
                    }
                }, 800);
            }, trialSpeed - 800);
        }
        
        // Cognitive interference functions for spatial mode
        function updateInterferenceStrength() {
            // Gradually increase interference as game progresses
            if (selectedMode === 'spatial') {
                // Start with mild interference and gradually increase
                const maxStrength = 20; // Maximum interference level
                const startTrial = 5; // When to start increasing interference
                
                if (currentTrial > startTrial) {
                    // Progressively increase interference strength
                    interferenceStrength = Math.min(maxStrength, 
                        Math.floor((currentTrial - startTrial) / 5) + 2);
                } else {
                    // Mild interference at start
                    interferenceStrength = 1;
                }
                
                console.log(`Interference strength set to: ${interferenceStrength}`);
            }
        }
        
        function setupInterferenceEffects() {
            if (selectedMode !== 'spatial' || !useInterference) return;
            
            // Clear previous interference effects
            clearAllInterferenceTimeouts();
            
            // Reset cell styles
            document.querySelectorAll('#spatialOnlyGrid .grid-cell').forEach(cell => {
                cell.className = 'grid-cell';
                Array.from(cell.querySelectorAll('.interference-overlay')).forEach(overlay => {
                    overlay.style.opacity = '0';
                });
            });
            
            // Hide all interference symbols
            if (interferenceSymbols.length > 0) {
                interferenceSymbols.forEach(symbol => {
                    symbol.style.opacity = '0';
                });
            }
            
            // No interference for the first few trials
            if (currentTrial < 5) return;
            
            // Generate fake active cells based on interference strength
            lastFakePositions = [...fakePositions]; // Store last fake positions
            fakePositions = [];
            
            // Choose number of fake positions based on interference strength
            const numFakePositions = Math.min(3, Math.floor(interferenceStrength / 5) + 1);
            
            // Generate fake positions avoiding the real position
            for (let i = 0; i < numFakePositions; i++) {
                let fakePos;
                do {
                    fakePos = generateRandomPosition();
                } while (fakePos === currentPosition || fakePositions.includes(fakePos));
                
                fakePositions.push(fakePos);
            }
            
            // Choose visual distortion type based on interference strength
            const distortions = [];
            
            if (interferenceStrength >= 3) {
                // Add visual noise
                document.querySelectorAll('#spatialOnlyGrid .grid-cell').forEach((cell, index) => {
                    const overlay = cell.querySelector('.interference-overlay');
                    if (overlay) {
                        const opacity = Math.min(0.3, interferenceStrength * 0.01);
                        overlay.style.opacity = opacity.toString();
                    }
                    
                    // Add subtle distortion classes
                    if (Math.random() < 0.3) {
                        const distortionClass = ['distorted', 'shifted', 'color-shift'][Math.floor(Math.random() * 3)];
                        distortions.push({ cell, class: distortionClass });
                    }
                });
            }
            
            if (interferenceStrength >= 10) {
                // Add floating interference symbols
                const numSymbols = Math.min(interferenceSymbols.length, interferenceStrength / 2);
                for (let i = 0; i < numSymbols; i++) {
                    const symbol = interferenceSymbols[i];
                    symbol.style.top = `${Math.random() * 100}%`;
                    symbol.style.left = `${Math.random() * 100}%`;
                    symbol.style.opacity = (0.3 + Math.random() * 0.4).toString();
                    symbol.style.color = getRandomColor(0.7);
                    symbol.style.fontSize = `${16 + Math.random() * 20}px`;
                    symbol.textContent = INTERFERENCE_SYMBOLS[Math.floor(Math.random() * INTERFERENCE_SYMBOLS.length)];
                }
            }
            
            // Apply delayed distortions to cause cognitive interference
            if (interferenceStrength >= 5) {
                interferenceTimeout = setTimeout(() => {
                    // Apply distortions with a delay
                    distortions.forEach(item => {
                        item.cell.classList.add(item.class);
                    });
                    
                    // Set up flashing interference
                    if (interferenceStrength >= 8) {
                        interferenceFlashTimeout = setTimeout(() => {
                            document.querySelectorAll('#spatialOnlyGrid .interference-overlay').forEach(overlay => {
                                overlay.classList.add('interference-flash');
                                setTimeout(() => overlay.classList.remove('interference-flash'), 300);
                            });
                        }, Math.random() * 2000);
                    }
                }, 800);
            }
            
            // Extreme cognitive interference with false nBack matches and mirroring
            if (interferenceStrength >= 15) {
                // Maybe add rotation to the entire grid
                if (Math.random() < 0.3) {
                    const grid = document.getElementById('spatialOnlyGrid');
                    gridRotationTimeout = setTimeout(() => {
                        grid.style.transform = 'rotate(180deg)';
                        setTimeout(() => {
                            grid.style.transform = 'none';
                        }, 200);
                    }, Math.random() * 1500);
                }
            }
        }

        function showCurrentTrial() {
            if (selectedMode === 'dual') {
                document.querySelectorAll('#spatialGrid .grid-cell').forEach(cell => {
                    cell.className = 'grid-cell';
                    cell.innerHTML = '';
                });
                
                const activeCell = document.getElementById(`spatialGrid-cell-${currentPosition}`);
                if (activeCell && currentPremises) {
                    activeCell.className = 'grid-cell active';
                    activeCell.innerHTML = `<div class="premise-text">${currentPremises.map(p => `<div>${p}</div>`).join('')}</div>`;
                }
            } else if (selectedMode === 'spatial') {
                document.querySelectorAll('#spatialOnlyGrid .grid-cell').forEach(cell => {
                    cell.classList.remove('active', 'fake-active');
                });
                
                // Show the active cell
                const activeCell = document.getElementById(`spatialOnlyGrid-cell-${currentPosition}`);
                if (activeCell) {
                    activeCell.classList.add('active');
                }
                
                // Add fake active cells for interference if enabled
                if (useInterference && interferenceStrength >= 6) {
                    fakePositions.forEach(fakePos => {
                        const fakeCell = document.getElementById(`spatialOnlyGrid-cell-${fakePos}`);
                        if (fakeCell) {
                            // Set timeout to show fake active cells with slight delay
                            setTimeout(() => {
                                fakeCell.classList.add('fake-active');
                                setTimeout(() => fakeCell.classList.remove('fake-active'), 200);
                            }, Math.random() * 500);
                        }
                    });
                }
            } else if (selectedMode === 'relational' || selectedMode === 'advanced' || selectedMode === 'ultra') {
                const premiseDisplay = document.getElementById('premiseDisplay');
                if (currentPremises) {
                    premiseDisplay.innerHTML = `<div class="premise-text-only">${currentPremises.map(p => `<div>${p}</div>`).join('')}</div>`;
                }
            }
            
            awaitingResponse = true;
            updateResponseOptions();
        }

        function hideCurrentTrial() {
            if (selectedMode === 'dual') {
                document.querySelectorAll('#spatialGrid .grid-cell').forEach(cell => {
                    cell.className = 'grid-cell';
                    cell.innerHTML = '';
                });
            } else if (selectedMode === 'spatial') {
                document.querySelectorAll('#spatialOnlyGrid .grid-cell').forEach(cell => {
                    cell.classList.remove('active', 'fake-active');
                });
            } else if (selectedMode === 'relational' || selectedMode === 'advanced' || selectedMode === 'ultra') {
                const premiseDisplay = document.getElementById('premiseDisplay');
                premiseDisplay.innerHTML = '';
            }
            
            awaitingResponse = false;
            updateResponseOptions();
        }

        function updateResponseOptions() {
            const canAnswer = currentTrial > nBackLevel && awaitingResponse;
            
            // Update button states and history messages
            const historyElements = [
                'spatialHistory', 'spatialOnlyHistory', 'relationalHistory', 'relationalOnlyHistory'
            ];
            
            historyElements.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    if (!canAnswer && currentTrial <= nBackLevel) {
                        element.classList.remove('hidden');
                        element.textContent = `Building history... (Trial ${nBackLevel + 1}+)`;
                    } else {
                        element.classList.add('hidden');
                    }
                }
            });
        }

        function handleSpatialResponse(isMatch) {
            if (!awaitingResponse || currentTrial <= nBackLevel || spatialResponseGiven) return;
            
            spatialResponseGiven = true;
            
            const nBackPosition = positionHistory[currentTrial - nBackLevel - 1];
            const actualMatch = nBackPosition !== undefined && nBackPosition === currentPosition;
            
            if (actualMatch && !isMatch) {
                spatialScore.missedMatches += 1;
            }
            
            const correct = isMatch === actualMatch;
            spatialScore.correct += correct ? 1 : 0;
            spatialScore.total += 1;
            
            // Visual feedback
            const buttons = ['spatialMatchBtn', 'spatialOnlyBtn'];
            buttons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.classList.add('active');
                    setTimeout(() => btn.classList.remove('active'), 300);
                }
            });
            
            showFeedback('spatial', correct, isMatch, actualMatch);
            updateDisplay();
        }

        function handleRelationalResponse(isCompatible) {
            if (!awaitingResponse || currentTrial <= nBackLevel || relationalResponseGiven) return;
            
            relationalResponseGiven = true;
            
            const nBackPremises = premisesHistory[currentTrial - nBackLevel - 1];
            const actualCompatible = nBackPremises !== undefined && 
                checkPremisesCompatibility(currentPremises, nBackPremises);
            
            if (actualCompatible && !isCompatible) {
                relationalScore.missedMatches += 1;
            }
            
            const correct = isCompatible === actualCompatible;
            relationalScore.correct += correct ? 1 : 0;
            relationalScore.total += 1;
            
            // Visual feedback
            const buttons = ['relationalMatchBtn', 'relationalOnlyBtn'];
            buttons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.classList.add('active');
                    setTimeout(() => btn.classList.remove('active'), 300);
                }
            });
            
            showFeedback('relational', correct, isCompatible, actualCompatible);
            updateDisplay();
        }

        function showFeedback(type, correct, userResponse, actualResponse) {
            const feedbackElements = [
                `${type}Feedback`, 
                `${type}OnlyFeedback`
            ];
            
            feedbackElements.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.classList.remove('hidden', 'correct', 'incorrect');
                    element.classList.add(correct ? 'correct' : 'incorrect');
                    element.textContent = correct ? '✓ Correct!' : '✗ Incorrect';
                    
                    setTimeout(() => {
                        element.classList.add('hidden');
                    }, 2000);
                }
            });
        }

        function updateDisplay() {
            if (gameState === 'playing') {
                const trialsAfterNBack = Math.max(0, currentTrial - nBackLevel);
                
                let displayHTML = `<div><strong>Trial:</strong> ${currentTrial}/${maxTrials}</div>`;
                
                if (selectedMode === 'spatial') {
                    const spatialMatchRate = trialsAfterNBack > 0 ? 
                        (spatialScore.actualMatches / trialsAfterNBack * 100).toFixed(1) : '0.0';
                    const spatialMissRate = spatialScore.actualMatches > 0 ? 
                        (spatialScore.missedMatches / spatialScore.actualMatches * 100).toFixed(1) : '0.0';
                    const spatialAccuracy = spatialScore.total > 0 ? 
                        (spatialScore.correct / spatialScore.total * 100).toFixed(1) : '0.0';
                    
                    displayHTML += `<div><strong>Spatial:</strong> ${spatialScore.correct}/${spatialScore.total} (${spatialAccuracy}%) | Matches: ${spatialScore.actualMatches}/${trialsAfterNBack} (${spatialMatchRate}%) | Missed: ${spatialScore.missedMatches} (${spatialMissRate}%)</div>`;
                    
                    // Show interference level for spatial mode
                    if (useInterference) {
                        displayHTML += `<div><strong>Interference Level:</strong> ${interferenceStrength}</div>`;
                    }
                } else if (selectedMode === 'dual') {
                    const spatialMatchRate = trialsAfterNBack > 0 ? 
                        (spatialScore.actualMatches / trialsAfterNBack * 100).toFixed(1) : '0.0';
                    const spatialMissRate = spatialScore.actualMatches > 0 ? 
                        (spatialScore.missedMatches / spatialScore.actualMatches * 100).toFixed(1) : '0.0';
                    const spatialAccuracy = spatialScore.total > 0 ? 
                        (spatialScore.correct / spatialScore.total * 100).toFixed(1) : '0.0';
                    
                    const relationalMatchRate = trialsAfterNBack > 0 ? 
                        (relationalScore.actualMatches / trialsAfterNBack * 100).toFixed(1) : '0.0';
                    const relationalMissRate = relationalScore.actualMatches > 0 ? 
                        (relationalScore.missedMatches / relationalScore.actualMatches * 100).toFixed(1) : '0.0';
                    const relationalAccuracy = relationalScore.total > 0 ? 
                        (relationalScore.correct / relationalScore.total * 100).toFixed(1) : '0.0';
                    
                    displayHTML += `<div><strong>Spatial:</strong> ${spatialScore.correct}/${spatialScore.total} (${spatialAccuracy}%) | Matches: ${spatialScore.actualMatches}/${trialsAfterNBack} (${spatialMatchRate}%) | Missed: ${spatialScore.missedMatches} (${spatialMissRate}%)</div>`;
                    displayHTML += `<div><strong>Relational:</strong> ${relationalScore.correct}/${relationalScore.total} (${relationalAccuracy}%) | Matches: ${relationalScore.actualMatches}/${trialsAfterNBack} (${relationalMatchRate}%) | Missed: ${relationalScore.missedMatches} (${relationalMissRate}%)</div>`;
                    
                    const totalAccuracy = (spatialScore.total + relationalScore.total) > 0 ? 
                        ((spatialScore.correct + relationalScore.correct) / (spatialScore.total + relationalScore.total) * 100).toFixed(1) : '0.0';
                    displayHTML += `<div><strong>Total Accuracy:</strong> ${totalAccuracy}%</div>`;
                } else if (selectedMode === 'relational' || selectedMode === 'advanced' || selectedMode === 'ultra') {
                    const relationalMatchRate = trialsAfterNBack > 0 ? 
                        (relationalScore.actualMatches / trialsAfterNBack * 100).toFixed(1) : '0.0';
                    const relationalMissRate = relationalScore.actualMatches > 0 ? 
                        (relationalScore.missedMatches / relationalScore.actualMatches * 100).toFixed(1) : '0.0';
                    const relationalAccuracy = relationalScore.total > 0 ? 
                        (relationalScore.correct / relationalScore.total * 100).toFixed(1) : '0.0';
                    
                    let taskName = 'Relational';
                    if (selectedMode === 'ultra') taskName = 'Ultra Reasoning';
                    else if (selectedMode === 'advanced') taskName = 'Advanced Reasoning';
                    
                    displayHTML += `<div><strong>${taskName}:</strong> ${relationalScore.correct}/${relationalScore.total} (${relationalAccuracy}%) | Matches: ${relationalScore.actualMatches}/${trialsAfterNBack} (${relationalMatchRate}%) | Missed: ${relationalScore.missedMatches} (${relationalMissRate}%)</div>`;
                }

                scoreDisplay.innerHTML = displayHTML;
                scoreDisplay.classList.remove('hidden');
            }
        }

        function updateSettingsDisplay() {
            const settingsDisplay = document.getElementById('settingsDisplay');
            
            let modeText = '';
            if (selectedMode === 'ultra') modeText = 'Ultra-N-Relational-Reasoning';
            else if (selectedMode === 'advanced') modeText = 'Advanced-N-Relational-Reasoning';
            else if (selectedMode === 'dual') modeText = 'Dual N-Back';
            else if (selectedMode === 'spatial') modeText = 'Spatial N-Back';
            else if (selectedMode === 'relational') modeText = 'Relational N-Back';
            
            let settingsHTML = `
                <div class="setting-item"><strong>Mode:</strong> ${modeText}</div>
                <div class="setting-item"><strong>N-Back Level:</strong> ${nBackLevel}</div>
                <div class="setting-item"><strong>Session Length:</strong> ${maxTrials} trials</div>
                <div class="setting-item"><strong>Trial Duration:</strong> ${trialSpeed / 1000}s</div>
            `;
            
            if (selectedMode === 'relational' || selectedMode === 'dual' || selectedMode === 'advanced' || selectedMode === 'ultra') {
                const labelText = (selectedMode === 'advanced' || selectedMode === 'ultra') ? 'Statements per Trial' : 'Premises per Trial';
                settingsHTML += `<div class="setting-item"><strong>${labelText}:</strong> ${premisesCount}</div>`;
            }
            
            if (selectedMode === 'spatial') {
                settingsHTML += `<div class="setting-item"><strong>Cognitive Interference:</strong> Enabled</div>`;
            }
            
            settingsDisplay.innerHTML = settingsHTML;
            settingsDisplay.classList.remove('hidden');
        }

        function togglePause() {
            const pauseBtn = document.getElementById('pauseBtn');
            
            if (isPlaying) {
                // Currently playing, so pause the game
                isPlaying = false;
                pauseBtn.innerHTML = '▶ Resume';
                gameState = 'paused';
                
                // Clear any pending trial timeout when pausing
                if (trialTimeout) {
                    clearTimeout(trialTimeout);
                    trialTimeout = null;
                }
                
                // Clear interference timeouts
                clearAllInterferenceTimeouts();
            } else {
                // Currently paused, so resume the game
                isPlaying = true;
                pauseBtn.innerHTML = '⏸ Pause';
                gameState = 'playing';
                
                // If we're in the middle of a trial (awaiting response), restart the current trial
                if (awaitingResponse && currentTrial > 0) {
                    // Restart the current trial timeout
                    trialTimeout = setTimeout(() => {
                        hideCurrentTrial();
                        setTimeout(() => {
                            if (isPlaying) {
                                startNewTrial();
                            }
                        }, 800);
                    }, trialSpeed - 800);
                } else {
                    // We're between trials, so start the next trial
                    startNewTrial();
                }
            }
        }

        function resetGame() {
            gameState = 'setup';
            isPlaying = false;
            currentTrial = 0;
            positionHistory = [];
            premisesHistory = [];
            spatialScore = { correct: 0, total: 0, actualMatches: 0, missedMatches: 0 };
            relationalScore = { correct: 0, total: 0, actualMatches: 0, missedMatches: 0 };
            currentPosition = null;
            currentPremises = null;
            awaitingResponse = false;
            spatialResponseGiven = false;
            relationalResponseGiven = false;
            sessionComplete = false;
            
            // Reset interference settings
            useInterference = false;
            interferenceStrength = 0;
            fakePositions = [];
            lastFakePositions = [];
            
            if (trialTimeout) {
                clearTimeout(trialTimeout);
                trialTimeout = null;
            }
            
            clearAllInterferenceTimeouts();
            
            gameScreen.classList.add('hidden');
            setupScreen.classList.remove('hidden');
            resultsScreen.classList.add('hidden');
            scoreDisplay.classList.add('hidden');
            document.getElementById('settingsDisplay').classList.add('hidden');
            
            renderSetupScreen();
        }

        function endSession() {
            isPlaying = false;
            sessionComplete = true;
            gameState = 'results';
            
            // Clear all timeouts
            if (trialTimeout) {
                clearTimeout(trialTimeout);
                trialTimeout = null;
            }
            clearAllInterferenceTimeouts();
            
            const totalCorrect = spatialScore.correct + relationalScore.correct;
            const totalQuestions = spatialScore.total + relationalScore.total;
            const totalActualMatches = spatialScore.actualMatches + relationalScore.actualMatches;
            const totalMatchRate = (currentTrial - nBackLevel) > 0 ? (totalActualMatches / (currentTrial - nBackLevel) * 100).toFixed(1) : '0.0';
            
            let scoresHTML = '';
            
            if (selectedMode === 'spatial' || selectedMode === 'dual') {
                scoresHTML += `
                    <div class="score-detail">
                        <strong>Spatial N-Back:</strong> ${spatialScore.correct}/${spatialScore.total} 
                        (${spatialScore.total > 0 ? Math.round((spatialScore.correct / spatialScore.total) * 100) : 0}%)
                        <br><em>Actual Matches: ${spatialScore.actualMatches} | Missed: ${spatialScore.missedMatches}</em>
                    </div>
                `;
                
                if (selectedMode === 'spatial') {
                    scoresHTML += `
                        <div class="score-detail">
                            <strong>Maximum Interference Level:</strong> ${interferenceStrength}
                        </div>
                    `;
                }
            }
            
            if (selectedMode === 'relational' || selectedMode === 'dual' || selectedMode === 'advanced' || selectedMode === 'ultra') {
                let taskName = 'Relational N-Back';
                if (selectedMode === 'ultra') taskName = 'Ultra-N-Relational-Reasoning';
                else if (selectedMode === 'advanced') taskName = 'Advanced-N-Relational-Reasoning';
                
                scoresHTML += `
                    <div class="score-detail">
                        <strong>${taskName}:</strong> ${relationalScore.correct}/${relationalScore.total} 
                        (${relationalScore.total > 0 ? Math.round((relationalScore.correct / relationalScore.total) * 100) : 0}%)
                        <br><em>Actual Matches: ${relationalScore.actualMatches} | Missed: ${relationalScore.missedMatches}</em>
                    </div>
                `;
            }
            
            if (selectedMode === 'dual') {
                scoresHTML += `
                    <div class="score-detail">
                        <strong>Combined Accuracy:</strong> ${totalQuestions > 0 ? Math.round((totalCorrect / totalQuestions) * 100) : 0}%
                        <br><em>Total Match Rate: ${totalMatchRate}%</em>
                    </div>
                `;
            }
            
            document.getElementById('finalScores').innerHTML = scoresHTML;
            
            gameScreen.classList.add('hidden');
            resultsScreen.classList.remove('hidden');
            scoreDisplay.classList.add('hidden');

            // Bind results screen events
            document.getElementById('newSessionBtn').addEventListener('click', resetGame);
            document.getElementById('changeModeBtn').addEventListener('click', () => {
                resultsScreen.classList.add('hidden');
                modeSelectionScreen.classList.remove('hidden');
                gameState = 'modeSelection';
                
                // Reset selections
                document.querySelectorAll('.mode-card').forEach(c => c.classList.remove('selected'));
                selectedMode = null;
                document.getElementById('continueToSetup').disabled = true;
            });
        }
    </script>
</body>
</html>
